{"version":3,"sources":["controller/MessageReceiver.tsx","controller/MessageSender.tsx","utils/FileDownload.tsx","controller/Controller.tsx","controller/TaskSequencer.tsx","runtime/PlayerCatalog.tsx","runtime/ItemCatalog.tsx","runtime/PlayerFrame.tsx","controller/App.tsx","index.tsx"],"names":["MessageReceiver","_classCallCheck","playerReadyListener","preloadReturnListener","getUserIdReturnListener","loginDialogClosedListener","getTaskReturnListener","getScoringResultReturnListener","traceLogListener","recordingListener","getTasksStateReturnListener","taskSwitchRequestListener","shinyTaskSwitchRequestListener","_createClass","key","value","_this","window","addEventListener","event","processMessageEvent","listener","this","origin","data","source","parent","dataObject","JSON","parse","e","console","info","concat","eventType","_dataObject$traceLogD","traceLogData","metaData","logEntriesList","log","stringify","map","entry","warn","_dataObject2","request","scope","item","task","undefined","_dataObject","userId","state","_dataObject$recording","recordingData","recordingEntriesList","result","fieldValue","id","isSuccess","message","sendMessageToTaskPlayer","targetWindow","payload","postMessage","targetOrigin","downloadAssessmentConfig","sendJsonDownloadRequest","then","response","candidate","tasks","Array","isArray","every","isTaskIdentification","error","isAssessmentConfiguration","Error","length","filename","Promise","resolve","reject","xhttp","XMLHttpRequest","responseType","onload","onerror","statusText","open","send","isPlayerConfiguration","playerId","runtimeVersion","frameContentFile","configureMessageReceiver","messageReceiver","taskSequencer","playerCatalog","itemCatalog","controllerConfig","setTaskSwitchRequestListener","sendingWindow","requestDetails","sendingPlayerId","getPlayerId","decision","cancel","nextTask","backTask","type","reason","goToTask","getNextAction","advisedPlayerId","targetPlayer","frameWindow","advisedFrame","getFrameWindow","getTargetPlayer","stopTask","doToAll","logout","show","showLogin","processLoginRequest","getScoringResult","setShinyTaskSwitchRequestListener","targetItemVersion","getVersion","compatiblePlayer","findCompatiblePlayer","startTask","processShinyTaskSwitchRequest","setLoginDialogClosedListener","nickname","setUserId","setTaskSequencer","configuration","initialize","loadItemsAndStartFirstTask","mathJaxCdnUrl","catch","setPlayerReadyListener","receiveReadySignal","channel","interval","targetWindowType","contextId","buildTraceContextId","sc","_objectSpread","setScalingConfiguration","scalingMode","alignmentHorizontal","alignmentVertical","document","location","search","replace","split","forEach","a","tmp","indexOf","extractScalingConfigurationFromQuery","assessmentConfiguration","all","taskConfiguration","filter","onlyUnique","itemName","isRegistered","itemRootPathPrefix","runtimeCompatibilityVersion","name","isItemConfiguration","downloadItemConfig","itemConfiguration","register","doToAllCompatible","itemConfig","resourcePath","externalResourcePath","libraryPathsMap","MathJax","installItem","installAllItems","firstTask","playerCount","getPlayerIds","startAdvice","itemVersion","getCompatiblePlayer","findCompatiblePlayerAndStartTask","index","toStart","titleLabel","fieldLabel","buttonLabel","v4","sendingPlayer","isCompatibleById","someCompatiblePlayer","TaskSequencer","currentTaskIndex","switchAndReturnTask","currentIndex","_","findMatchingTask","getIndexToPick","failureMessage","indexToPick","findIndex","PlayerCatalog","totalPlayerCount","players","pendingReadySignals","Set","frameRef","compatibilityChecker","newPlayer","isCompatible","readyFlag","push","applyPendingReadySignal","sourceWindow","receivingPlayer","findPlayerByWindow","add","_this$findPlayerById","findPlayerById","_this$findPlayerByWin","find","playerInfo","action","player","frame","current","style","visibility","playerWindow","has","delete","ItemCatalog","items","version","findByName","_this$findByName","PlayerFrame","props","_props$playerConfigur","playerConfiguration","React","useRef","divRef","useEffect","_frameRef$current","contentWindow","registerPlayer","_jsxs","className","ref","position","top","left","borderStyle","width","height","display","alignItems","justifyContent","children","showPlayerInfo","fontSize","_jsx","title","src","frameBorder","scrolling","App","controllerConfiguration","playersArray","itemHeight","itemSize","itemWidth","traceLogTransmission","transmitUrl","httpTimeout","isLogTransmissionConfiguration","isControllerConfiguration","startReceiving","buildMessageReceiver","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.46a4e3c3.chunk.js","sourcesContent":["import { PreloadResultStruct } from './PreloadResultStruct';\n\n/**\n * Service that receives messages from the task players \n * and delivers them to the configured listeners. \n * \n * All listeners are called with the frame window of the sending task player\n * (besides the specific message content).\n */\nexport default class MessageReceiver {\n  private playerReadyListener : ((source: MessageEventSource) => void) | 'noListener' = 'noListener'; \n  private preloadReturnListener : ((source: MessageEventSource, result : PreloadResultStruct) => void) | 'noListener' = 'noListener'; \n  private getUserIdReturnListener : ((source: MessageEventSource, result : string) => void) | 'noListener' = 'noListener'; \n  private loginDialogClosedListener : ((source: MessageEventSource, result : string) => void) | 'noListener' = 'noListener'; \n  private getTaskReturnListener : ((source: MessageEventSource, result: GetTaskReturn) => void) | 'noListener' = 'noListener'; \n  private getScoringResultReturnListener : ((source: MessageEventSource, result: string) => void) | 'noListener' = 'noListener'; \n  \n  private traceLogListener : ((source: MessageEventSource, metaData: string, logEntriesList: string[]) => void) | 'noListener' = 'noListener'; \n  private recordingListener : ((source: MessageEventSource, metaData: string, recordingEntriesList: string[]) => void) | 'noListener' = 'noListener'; \n  private getTasksStateReturnListener : ((source: MessageEventSource, userId: string, state: string) => void) | 'noListener' = 'noListener'; \n\n  private taskSwitchRequestListener : ((source: MessageEventSource, request: RequestType, requestDetails?: TaskRequestDetails) => void) | 'noListener' = 'noListener'; \n  \n  private shinyTaskSwitchRequestListener : ((source: MessageEventSource, requestDetails: ShinySwitchRequest) => void) | 'noListener' = 'noListener'; \n\n  /**\n   * Start to receive messages.\n   */\n  public startReceiving() {\n    window.addEventListener(\"message\", (event) => {\n      this.processMessageEvent(event);\n    })\n  \n  }\n  \n  public setPlayerReadyListener(listener: (source: MessageEventSource) => void) : void {\n    this.playerReadyListener = listener;\n  }\n\n  public setPreloadReturnListener(listener: (source: MessageEventSource, result : PreloadResultStruct) => void) : void {\n    this.preloadReturnListener = listener;\n  }\n\n  public setGetUserIdReturnListener(listener: (source: MessageEventSource, result : string) => void) : void {\n    this.getUserIdReturnListener = listener;\n  }\n\n  public setLoginDialogClosedListener(listener: (source: MessageEventSource, result : string) => void) : void {\n    this.loginDialogClosedListener = listener;\n  }\n\n  public setGetTaskReturnListener(listener: (source: MessageEventSource, result: GetTaskReturn) => void) : void {\n    this.getTaskReturnListener = listener;\n  }\n\n  public setGetScoringResultReturnListener(listener: (source: MessageEventSource, result: string) => void) : void {\n    this.getScoringResultReturnListener = listener;\n  }\n\n  public setTraceLogListener(listener: (source: MessageEventSource, metaData: string, logEntriesList: string[]) => void) : void {\n    this.traceLogListener = listener;\n  }\n\n  public setRecordingListener(listener: (source: MessageEventSource, metaData: string, recordingEntriesList: string[]) => void) : void {\n    this.recordingListener = listener;\n  }\n\n  public setGetTasksStateReturnListener(listener: (source: MessageEventSource, userId: string, state: string) => void) : void {\n    this.getTasksStateReturnListener = listener;\n  }\n\n  public setTaskSwitchRequestListener(listener: (source: MessageEventSource, request: RequestType, requestDetails?: TaskRequestDetails) => void) : void {\n    this.taskSwitchRequestListener = listener;\n  }\n\n  public setShinyTaskSwitchRequestListener(listener: (source: MessageEventSource, requestDetails: ShinySwitchRequest) => void) : void {\n    this.shinyTaskSwitchRequestListener = listener;\n  }\n\n  private processMessageEvent(event : MessageEvent<any>) : void {\n    const { origin, data, source } = event;\n\n    if (source === null) {\n      console.warn(`Ignoring message without source.`);\n      return;\n    }\n\n    if (origin !== window.origin) {\n      console.warn(`Ignoring message from wrong origin. Message origin is ${origin}. Accepted origin is ${window.origin}.`);\n      return;\n    }\n\n    //assume it's a PM from shiny\n    if(source === window.parent && typeof data === \"object\" && this.shinyTaskSwitchRequestListener !== \"noListener\"){\n      // console.log(data);\n      this.shinyTaskSwitchRequestListener(source, data as ShinySwitchRequest);\n      return;\n    }\n\n\n    let dataObject;\n    try {\n      dataObject = JSON.parse(data);\n    } catch (e) {\n      console.info(`Ignoring message with non-JSON data: ${data}`);\n      return;\n    }\n\n    const eventType = dataObject.eventType;\n\n    if (eventType === 'taskPlayerReady' && this.playerReadyListener !== 'noListener') {\n      this.playerReadyListener(source);\n      return;\n    }\n\n    if (eventType === 'setPreloadReturn' && this.preloadReturnListener !== 'noListener') {\n      const result : PreloadResultStruct = { isSuccess: dataObject.isSuccess, message: dataObject.message };\n      this.preloadReturnListener(source, result);\n      return;\n    }\n\n    if (eventType === 'getUserIdReturn' && this.getUserIdReturnListener !== 'noListener') {\n      this.getUserIdReturnListener(source, dataObject.id);\n      return;\n    }\n\n    if (eventType === 'loginDialogClosed' && this.loginDialogClosedListener !== 'noListener') {\n      this.loginDialogClosedListener(source, dataObject.fieldValue);\n      return;\n    }\n\n    if (eventType === 'getTaskReturn' && this.getTaskReturnListener !== 'noListener') {\n      this.getTaskReturnListener(source, {scope: dataObject.scope, item: dataObject.item, task: dataObject.task});\n      return;\n    }\n\n    if (eventType === 'getScoringResultReturn' && this.getScoringResultReturnListener !== 'noListener') {\n      this.getScoringResultReturnListener(source, JSON.stringify(dataObject.result));\n      return;\n    }\n\n    if (eventType === 'traceLogTransmission' && this.traceLogListener !== 'noListener') {\n      const {metaData, logEntriesList} = dataObject.traceLogData;\n      console.log(dataObject.traceLogData);\n      this.traceLogListener(source, JSON.stringify(metaData), logEntriesList.map((entry : object) => JSON.stringify(entry)));\n      return;\n    }\n\n    if (eventType === 'recordingTransmission' && this.recordingListener !== 'noListener') {\n      const {metaData, recordingEntriesList} = dataObject.recordingData;\n      this.recordingListener(source, JSON.stringify(metaData), recordingEntriesList.map((entry : object) => JSON.stringify(entry)));\n      return;\n    }\n\n    if (eventType === 'getTasksStateReturn' && this.getTasksStateReturnListener !== 'noListener') {\n      const {userId, state} = dataObject;\n      this.getTasksStateReturnListener(source, userId, JSON.stringify(state));\n      return;\n    }\n\n    if (eventType === 'taskSwitchRequest' && this.taskSwitchRequestListener !== 'noListener') {\n      const {request, scope, item, task} = dataObject;\n      this.taskSwitchRequestListener(source, request, request === 'goToTask' ? {scope, item, task} : undefined);\n      return;\n    }\n\n    console.warn(`Ignoring message not matching any listener: ${data}`)\n\n  }\n\n  private processShinyMessage(data : any){\n    console.log(data);\n  }\n\n}\n\n\n/**\n * Structures describing a task switch request:\n */\nexport type RequestType = 'nextTask' | 'previousTask' | 'cancelTask' | 'goToTask';\n\nexport interface TaskRequestDetails {\n  item?: string, \n  task: string, \n  scope: string\n}\n\nexport interface GetTaskReturn {\n  item: string, \n  task?: string, \n  scope: string\n}\n\nexport interface ShinySwitchRequest {\n  item: [string], \n  runtime: [string], \n  task: [string],\n  scope?: [string]\n}\n","/**\n * Send a message to the TaskPlayer running in the given target window.\n * \n * This method covers all messages defined by the TaskPlayer API\n * (even though we currently do not use all of them).\n */\nexport function sendMessageToTaskPlayer(targetWindow : MessageEventSource, payload : \n    // configuration control\n    { eventType: 'setWaitMessages', primary: string, secondary: string} | \n    { eventType: 'addItem', itemConfig: object, resourcePath: string, externalResourcePath: string, libraryPathsMap: {MathJax: string} } |\n    { eventType: 'clearItems'} |\n    { eventType: 'setPreload', itemName: string} |\n    // trace control\n    { eventType: 'insertMessageInTrace', message: string} |\n    { eventType: 'logStateToTrace'} |\n    { eventType: 'flushTrace'} |\n    { eventType: 'setTraceLogTransmissionChannel', channel: 'postMessage', targetWindowType?: string, targetOrigin?: string, interval: number} |\n    { eventType: 'setTraceLogTransmissionChannel', channel: 'http',  transmitUrl?: string,  interval: number,  httpTimeout?: number} |\n    { eventType: 'setTraceLogTransmissionChannel', channel: 'console',  interval: number} |\n    { eventType: 'setTraceContextId', contextId: string} |\n    // recordings control \n    { eventType: 'setRecordingTransmissionChannel', channel: 'http', transmitUrl: string, httpTimeout: number} |\n    { eventType: 'setRecordingTransmissionChannel', channel: 'console'} |\n    { eventType: 'setRecordingContextId', contextId: string} |\n    // user control\n    { eventType: 'setUserId', id: string} |\n    { eventType: 'logout'} |\n    { eventType: 'getUserId'} |\n    { eventType: 'showLogin', titleLabel: string, fieldLabel: string, buttonLabel: string} |\n    // task control\n    { eventType: 'startTask', scope: string, item: string, task: string} |\n    { eventType: 'stopTask'} |\n    { eventType: 'pauseTask' } |\n    { eventType: 'resumeTask' } |\n    { eventType: 'getTask' } |\n    { eventType: 'setTaskSequencer', targetWindowType: 'parent', targetOrigin: string} |\n    { eventType: 'setSwitchAvailability', request: 'nextTask' | 'previousTask' | 'cancelTask', value: boolean} |\n    { eventType: 'setSwitchAvailability', request: 'goToTask', scope: string, item?: string, task: string, value: boolean} |\n    { eventType: 'setScalingConfiguration', scalingMode: string, alignmentHorizontal: string, alignmentVertical: string} | \n    // task state control\n    { eventType: 'getTasksState'} |\n    { eventType: 'clearTasksState' } |\n    { eventType: 'preloadTasksState', state: string } |\n    // scoring control\n    { eventType: 'getScoringResult'} |\n    // state machine control\n    { eventType: 'sendStatemachineEvent', event: string} |\n    // header control\n    { eventType: 'setHeaderButtons', headerButtons: HeaderButtonDescription[]} |\n    { eventType: 'setMenuCarousels', course: string[], scopes: HeaderMenuScopeDescription[]} |\n    // developer mode control\n    { eventType: 'activateDebuggingWindows', scoreHotKey: string, traceHotKey: string, statemachineHotKey: string}\n  ) \n{\n  targetWindow.postMessage(JSON.stringify(payload), { targetOrigin: '*'});\n}\n\n\nexport interface HeaderButtonDescription {\n  image?: string, \n  text: string,\n  event: string,\n  height: number,\n  width: number\n}\n\nexport interface HeaderMenuScopeDescription {\n  name: string, \n  tasks: {item: string, task: string}[]\n}","/**\n * Asynchronous methods that download files and provide their content as proper structures.\n */\n\n// ----------------- public API --------------------------------------------------------------\n\n/**\n * Return a promise that downloads the controller configuration.\n */\n export function downloadControllerConfig() : Promise<ControllerConfiguration> {\n  const fullConfigFileName = `./controller/config.json`;\n  return sendJsonDownloadRequest(fullConfigFileName).then(\n    (response) => {\n      if(!isControllerConfiguration(response)) {\n        throw new Error(`Controller configuration is invalid: ${JSON.stringify(response)}`);\n      }\n      console.log(`Received controller configuration`, response);\n      return response;\n    }\n  );\n}\n\n\n/**\n * Return a promise that downloads the assessment configuration.\n */\nexport function downloadAssessmentConfig() : Promise<AssessmentConfiguration> {\n  const fullConfigFileName = `./assessments/config.json`;\n  return sendJsonDownloadRequest(fullConfigFileName).then(\n    (response) => {\n      if(!isAssessmentConfiguration(response)) {\n        throw new Error(`Assessment configuration is invalid: ${JSON.stringify(response)}`);\n      }\n      if (response.tasks.length < 1) {\n        throw new Error(`Assessment configuration contains no tasks: ${JSON.stringify(response)}`);\n      }\n      console.log(`Received assessment configuration`, response);\n      return response;\n    }\n  );\n}\n\n\n/**\n * Return a promise that downloads the item configuration for the given item.\n *\n *  The corresponding *.json file must have this name with .json appended as extension.\n */\nexport function downloadItemConfig(itemName : string) : Promise<ItemConfiguration> {\n  const fullConfigFileName = `./items/${itemName}/config.json`;\n  return sendJsonDownloadRequest(fullConfigFileName).then(\n    (response) => {\n      if(!isItemConfiguration(response)) {\n        throw new Error(`Configuration of ${itemName} is invalid: ${JSON.stringify(response)}`);\n      }\n      console.log(`Received configuration of ${itemName}`, response);\n      return response;\n    }\n  );\n}\n\n\nexport function extractScalingConfigurationFromQuery() :ScalingConfiguration{\n  let sc :any = {scalingMode: \"scale-up-down\", alignmentHorizontal: \"center\", alignmentVertical: \"center\"};\n  if(window.document.location.search.length){\n    try {\n      document.location.search\n      .replace('?', '')\n      .split('&')\n      .forEach((a) => {\n        let tmp = a.split('=');\n        if(tmp.length===2 && [\"scalingMode\", \"alignmentHorizontal\", \"alignmentVertical\"].indexOf(tmp[0])>=0)\n          sc[tmp[0]] = tmp[1];\n      });\n    } catch (error) {\n      console.error(\"error parsing scaling configuration: \" + error);\n    }\n  }\n  return sc as ScalingConfiguration;\n}\n\n/**\n * The content of the assessment configuration file.\n */\nexport interface AssessmentConfiguration {\n  tasks: TaskIdentification[]\n}\n\nexport interface TaskIdentification {\n  item: string, \n  task: string, \n  scope: string\n}\n\n/**\n * The content of an item configuration file (as far as we need it).\n */\nexport interface ItemConfiguration {\n  runtimeCompatibilityVersion: string,\n  name: string\n}\n\n/**\n * The content of the controller configuration file.\n */\nexport interface ControllerConfiguration {\n  traceLogTransmission?: LogTransmissionConfiguration\n  mathJaxCdnUrl?: string,\n  itemSize?: {\n    height: number,\n    width: number\n  },\n  players: PlayerConfiguration[],\n  showPlayerInfo: boolean\n}\n\nexport interface LogTransmissionConfiguration {\n  transmitUrl: string,\n  interval: number, \n  httpTimeout: number, \n}\n\nexport interface PlayerConfiguration {\n  playerId: string,\n  runtimeVersion: string,\n  frameContentFile: string,\n}\n\nexport interface ScalingConfiguration {\n  scalingMode: string, \n  alignmentHorizontal: string, \n  alignmentVertical: string\n}\n\n\n// ----------------- private stuff --------------------------------------------------------------\n\n/**\n * Return a Promise that processes a GET request for the given file.\n */\nfunction sendJsonDownloadRequest(filename : string) : Promise<any> {\n  return new Promise((resolve, reject) => {\n    const xhttp = new XMLHttpRequest();\n    xhttp.responseType = 'json';\n    xhttp.onload = () => resolve(xhttp.response);\n    xhttp.onerror = () => reject(xhttp.statusText);\n    xhttp.open('GET', filename, true);\n    xhttp.send();\n  });\n}\n\n/**\n * Runtime type checker for AssessmentConfiguration candidates.\n */\n function isAssessmentConfiguration(candidate: any) : candidate is AssessmentConfiguration {\n  try {\n    return candidate.tasks && Array.isArray(candidate.tasks) && candidate.tasks.every(isTaskIdentification); \n  }\n  catch(error) {\n    return false;\n  }\n}\n\n/**\n * Runtime type checker for TaskIdentification candidates.\n */\nfunction isTaskIdentification(candidate: any) : candidate is TaskIdentification {  \n  try {\n    return (\n      candidate.item && typeof candidate.item === 'string' &&\n      candidate.task && typeof candidate.task === 'string' &&\n      candidate.scope && typeof candidate.scope === 'string' \n    );\n  }\n  catch(error) {\n    return false;\n  }\n}\n\n/**\n * Runtime type checker for ItemConfiguration candidates.\n * \n * We just check some 'marker' members. \n */\n function isItemConfiguration(candidate: any) : candidate is ItemConfiguration {  \n  try {\n    return (\n      candidate.runtimeCompatibilityVersion && typeof candidate.runtimeCompatibilityVersion === 'string' &&\n      candidate.name && typeof candidate.name === 'string'\n    );\n  }\n  catch(error) {\n    return false;\n  }\n}\n\n/**\n * Runtime type checker for ControllerConfiguration candidates.\n */\n function isControllerConfiguration(candidate: any) : candidate is ControllerConfiguration {  \n  try {\n    return (\n        candidate.traceLogTransmission === undefined || isLogTransmissionConfiguration(candidate.traceLogTransmission)\n      ) && (\n        candidate.mathJaxCdnUrl === undefined || \n        (\n          candidate.mathJaxCdnUrl && typeof candidate.mathJaxCdnUrl === 'string'\n        )      \n      ) && (\n        candidate.itemSize === undefined ||\n        (\n          candidate.itemSize.height && typeof candidate.itemSize.height === 'number' &&\n          candidate.itemSize.width && typeof candidate.itemSize.width === 'number'\n        )\n      ) && (\n        candidate.players && Array.isArray(candidate.players) && candidate.players.every(isPlayerConfiguration)\n      ) && (\n        typeof candidate.showPlayerInfo === 'boolean'\n      )\n      ;\n  }\n  catch(error) {\n    return false;\n  }\n}\n\n/**\n * Runtime type checker for LogTransmissionConfiguration candidates.\n */\n function isLogTransmissionConfiguration(candidate: any) : candidate is LogTransmissionConfiguration {  \n  try {\n    return (\n          candidate.transmitUrl && typeof candidate.transmitUrl === 'string' &&\n          candidate.interval && typeof candidate.interval === 'number' &&\n          candidate.httpTimeout && typeof candidate.httpTimeout === 'number'\n    );\n  }\n  catch(error) {\n    return false;\n  }\n}\n\n/**\n * Runtime type checker for PlayerConfiguration candidates.\n */\n function isPlayerConfiguration(candidate: any) : candidate is PlayerConfiguration {  \n  try {\n    return (\n      candidate.playerId && typeof candidate.playerId === 'string' &&\n      candidate.runtimeVersion && typeof candidate.runtimeVersion === 'string' &&\n      candidate.frameContentFile && typeof candidate.frameContentFile === 'string' \n    );\n  }\n  catch(error) {\n    return false;\n  }\n}\n","import { v4 } from 'uuid'; \nimport MessageReceiver, { TaskRequestDetails, RequestType, ShinySwitchRequest } from \"./MessageReceiver\";\nimport { sendMessageToTaskPlayer } from \"./MessageSender\";\nimport { \n  ControllerConfiguration, \n  LogTransmissionConfiguration, \n  AssessmentConfiguration, \n  downloadAssessmentConfig, \n  ScalingConfiguration,\n  extractScalingConfigurationFromQuery,\n  downloadItemConfig,\n} from \"../utils/FileDownload\"; \nimport TaskSequencer, { Decision } from \"./TaskSequencer\";\nimport { TaskIdentification } from \"../utils/FileDownload\";\nimport PlayerCatalog from '../runtime/PlayerCatalog';\nimport ItemCatalog from '../runtime/ItemCatalog';\n\n/**\n * Controller coordinating actions required to run the tasks list in the available task players.\n * \n * The controller supports multiple task player instances running in different frames (to support\n * multiple CBA runtime versions). It gets access to these instances and their frames via a player catalog. \n * \n * All activity is triggered by the events coming in from the CBA runtimes once the task players have started there:\n * \n * The task-player-ready events coming in trigger configuration of the sending task player:\n *  - Set session ID (each player gets its own session ID).\n *  - Configure trace log transmission channel for the sending task player.\n * \n * The last task-player-ready event coming in also triggers the login phase:\n *  - Show login dialog in the sending task player.\n * \n * The login-done event triggers the initialization phase which ends with starting a first task:\n *  - Set the user ID for all available task players.\n *  - Download of configuration data and item data.\n *  - For each item not yet registered in the item catalog:\n *     * Register the item in the item catalog.\n *     * Determine the compatible task players and upload the item configuration there.\n *  - Establish a task sequencer.\n *  - Obtain the first task to run from the task sequencer and start it on the task player determined by the task sequencer. \n * \n * The task-switch-request events trigger task-switch responses determined by our task sequencer logic:\n *  - The controller informs the task sequencer about the request and the task player sending it. \n *  - The task sequencer tells the controller what to do next: Show a login dialog or start a task on a specific task player. \n *  - The controller stops the currently running task and \n *     * either shows a login dialog on the chosen task player \n *     * or starts the next task on the chosen task player.\n *  - If the task sequencer does not choose the next task player the controller picks one:\n *     * If the previous task player is compatible, it reuses that one. \n *     * Otherwise It picks some compatible player. \n * \n * Since the controller does not maintain any internal memory (for now) \n * it is just a method that configures the listeners in the message receiver.\n * \n */\n\n\n/**\n * Establish the controller, i.e. configure listeners in the message receiver. \n * \n * This defines our response to the messages coming in from the task players running in the CBA runtimes. \n * \n * The controller's activity is driven by the messages coming in from the task players: \n * - The 'ready' messages trigger the login phase.\n * - The 'login-done' message triggers the item initialization phase which will download items and start the first task of the assessment.\n * - Task switch request messages trigger task selection and task stop/start respones. \n */\nexport function configureMessageReceiver(\n  messageReceiver: MessageReceiver, \n  taskSequencer: TaskSequencer, \n  playerCatalog: PlayerCatalog,\n  itemCatalog: ItemCatalog,  \n  controllerConfig: ControllerConfiguration\n) \n{\n\n\n  // What to do once a task switch request arrives: get next action from task sequencer and run it.\n  messageReceiver.setTaskSwitchRequestListener((sendingWindow: MessageEventSource, request: RequestType, requestDetails?: TaskRequestDetails) => {\n    \n    const sendingPlayerId = playerCatalog.getPlayerId(sendingWindow);\n    if (sendingPlayerId === undefined) {\n      console.warn(`Received switch request from unknown task player frame. This is an internal error. We ignored the request.`);\n      return;\n    }\n    \n    const decision = getNextAction(sendingPlayerId, request, requestDetails, taskSequencer);\n    switch (decision.type) {\n      case 'blocked': \n        console.log(`Cannot follow switch request ${request}: ${decision.reason}. We ignored the request.`)\n        /********* \"Hack\" to send PM to parent frame when the last task of the sequence has been reached to signal the end of the test *******/\n        // if(request === \"nextTask\"){\n        //     window.parent.postMessage(\n        //       JSON.stringify({eventType: \"endOfSequence\"}),\n        //       \"*\"\n        //     );\n        // }\n        return;\n      case 'login': \n        processLoginRequest(decision.playerId, sendingPlayerId, sendingWindow, playerCatalog);\n        return;\n      case 'taskSwitch': \n        //task switch determined by shiny app based on scoring result\n          // processTaskSwitchRequest(decision.playerId, decision.nextTask, sendingPlayerId, sendingWindow, itemCatalog, playerCatalog);\n          getScoringResult(sendingWindow);\n        return;\n      default: \n        const _exhaustiveCheck : never = decision;\n        return _exhaustiveCheck;\n    }\n\n  })\n\n  messageReceiver.setShinyTaskSwitchRequestListener((sendingWindow: MessageEventSource, requestDetails: ShinySwitchRequest) => {\n    requestDetails.scope = requestDetails.scope ? requestDetails.scope : [\"A\"];\n    processShinyTaskSwitchRequest({item: requestDetails.item[0], task: requestDetails.task[0], scope: requestDetails.scope[0]} as TaskIdentification, itemCatalog, playerCatalog);\n  });\n\n  // What to do once login is finished: Download configuration, set up everything, and start first task.\n  messageReceiver.setLoginDialogClosedListener((sendingWindow, nickname) => {\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setUserId(nickname, targetWindow));\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setTaskSequencer(targetWindow));\n    downloadAssessmentConfig()\n      .then((configuration) => {\n        if (configuration.tasks.length < 1) {\n          throw new Error(`No tasks declared in assessment configuration ${configuration}`);\n        }\n        taskSequencer.initialize(configuration, playerCatalog);\n        loadItemsAndStartFirstTask(configuration, controllerConfig.mathJaxCdnUrl, playerCatalog, itemCatalog, taskSequencer);\n      })\n      .catch((error) => {\n        console.warn(`Could not initialize assessment properly: ${error.message}`);\n      });\n  })\n  \n  // What to do once the task player is ready: Load required items and show login dialog.\n  messageReceiver.setPlayerReadyListener((sendingWindow) => {\n    playerCatalog.receiveReadySignal(sendingWindow);\n    \n    // initializeSessionAndShowLogin(sendingWindow, controllerConfig.traceLogTransmission, playerCatalog)\n    // setUserId(\"DEPP\", sendingWindow);\n\n    sendMessageToTaskPlayer(sendingWindow, {\n      eventType: 'setTraceLogTransmissionChannel', \n      channel: 'postMessage', \n      interval: 5000, \n      targetOrigin: '*', \n      targetWindowType: \"parent\"\n    });    \n    sendMessageToTaskPlayer(sendingWindow, {eventType: 'setTraceContextId', contextId: buildTraceContextId()});\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setUserId(\"DEPP\", targetWindow));\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setTaskSequencer(targetWindow));\n    downloadAssessmentConfig()\n    .then((configuration) => {\n        if (configuration.tasks.length < 1) {\n          throw new Error(`No tasks declared in assessment configuration ${configuration}`);\n        }\n        taskSequencer.initialize(configuration, playerCatalog);\n        playerCatalog.doToAll((targetWindow: MessageEventSource) => setScalingConfiguration(targetWindow, extractScalingConfigurationFromQuery()));      \n        loadItemsAndStartFirstTask(configuration, controllerConfig.mathJaxCdnUrl, playerCatalog, itemCatalog, taskSequencer);        \n      })       \n      .catch((error) => {\n        console.warn(`Could not initialize assessment properly: ${error.message}`);\n      });\n  });\n\n}\n\n/**\n * Obtain the next action by asking the task sequencer. \n */\n function getNextAction(\n  sendingPlayerId: string, \n  request: RequestType, \n  requestDetails: TaskRequestDetails | undefined, \n  taskSequencer: TaskSequencer\n  ) : Decision\n{\n  switch (request) {\n    case 'cancelTask': return taskSequencer.cancel(sendingPlayerId);\n    case 'nextTask': return taskSequencer.nextTask(sendingPlayerId);\n    case 'previousTask': return taskSequencer.backTask(sendingPlayerId);\n    case 'goToTask': {\n      if (requestDetails === undefined) return { type: 'blocked', reason: 'Task specification is missing in goToTask request.' }\n      return taskSequencer.goToTask(sendingPlayerId, requestDetails);\n    }\n    default: {\n      const _exhaustiveCheck: never = request;\n      return _exhaustiveCheck;\n    }\n  }\n}\n\n/**\n * Process a request to show a new login.\n * \n * We stop the currently running task and show the login dialog.\n */\nfunction processLoginRequest(advisedPlayerId: string | undefined, sendingPlayerId: string, sendingWindow: MessageEventSource, playerCatalog: PlayerCatalog) : void {\n  const targetPlayer = getTargetPlayer(advisedPlayerId, sendingPlayerId, sendingWindow, playerCatalog);\n\n  stopTask(sendingWindow);\n  playerCatalog.doToAll((targetWindow: MessageEventSource) => {logout(targetWindow)});\n  playerCatalog.show(targetPlayer.id);\n  showLogin(targetPlayer.frameWindow);\n  return;\n}\n\n/**\n * Process a request to switch to another task.\n * \n * We stop the currently running task and start the new one.\n */\nfunction processTaskSwitchRequest(\n  advisedPlayerId: string | undefined, \n  nextTask: TaskIdentification, \n  sendingPlayerId: string, \n  sendingWindow: MessageEventSource, \n  itemCatalog: ItemCatalog, \n  playerCatalog: PlayerCatalog) : void \n{\n  const targetItemVersion = itemCatalog.getVersion(nextTask.item);\n  if (targetItemVersion === undefined) {\n    console.warn(`Received task switch request to unknown item ${nextTask.item}. We ignored the request.`);\n    return;\n  }\n\n  const compatiblePlayer = getCompatiblePlayer(advisedPlayerId, targetItemVersion, {id: sendingPlayerId, frameWindow: sendingWindow}, playerCatalog);\n  if (compatiblePlayer === undefined) {\n    console.warn(`Received task switch request to item ${nextTask.item} with version ${targetItemVersion} and could not find a compatible task player. We ignored the request.`);\n    return;\n  }\n  \n  getScoringResult(sendingWindow)\n  stopTask(sendingWindow);\n  playerCatalog.show(compatiblePlayer.id);\n  startTask(nextTask, compatiblePlayer.frameWindow);\n  return;\n\n}\n\nfunction processShinyTaskSwitchRequest(\n  nextTask: TaskIdentification,  \n  itemCatalog: ItemCatalog, \n  playerCatalog: PlayerCatalog) : void \n{\n  console.log(nextTask);\n  const targetItemVersion = itemCatalog.getVersion(nextTask.item);\n  if (targetItemVersion === undefined) {\n    console.warn(`Received task switch request to unknown item ${nextTask.item}. We ignored the request.`);\n    return;\n  }\n\n  // const compatiblePlayer = getCompatiblePlayer(advisedPlayerId, targetItemVersion, {id: sendingPlayerId, frameWindow: sendingWindow}, playerCatalog);\n  const compatiblePlayer = playerCatalog.findCompatiblePlayer(targetItemVersion);\n  if (compatiblePlayer === undefined) {\n    console.warn(`Received task switch request to item ${nextTask.item} with version ${targetItemVersion} and could not find a compatible task player. We ignored the request.`);\n    return;\n  }\n  \n  // stopTask(sendingWindow);\n  playerCatalog.doToAll(targetWindow => {\n    stopTask(targetWindow);\n  });\n  playerCatalog.show(compatiblePlayer.id);\n  startTask(nextTask, compatiblePlayer.frameWindow);\n  return;\n}\n \n/**\n * Load all required items and start the first task as advised by the task sequencer.\n */\nfunction loadItemsAndStartFirstTask(\n  configuration: AssessmentConfiguration, \n  mathJaxCdnUrl: string | undefined,\n  playerCatalog: PlayerCatalog, \n  itemCatalog: ItemCatalog,\n  taskSequencer: TaskSequencer,\n) : void {\n  Promise.resolve()\n    .then(() => installAllItems(configuration, mathJaxCdnUrl, playerCatalog, itemCatalog))\n    .then(() => {\n      const firstTask = taskSequencer.firstTask();\n      if (firstTask === undefined) {\n        throw new Error(`Invalid task sequencer configuration blocks starting the first task.`);\n      }\n      window.postMessage(JSON.stringify({eventType: \"itemsLoadedInPlayer\", playerCount: playerCatalog.getPlayerIds().length}),\"*\");\n      findCompatiblePlayerAndStartTask(firstTask, playerCatalog, itemCatalog)\n    })\n    .catch((error) => {\n      console.warn(`Could not properly initialize items and start first task: ${error.message}`);\n    });\n}\n\n/**\n * Build a promise that installs all items contained in the given assessment configuration.\n */\nfunction installAllItems(\n  assessmentConfiguration: AssessmentConfiguration, \n  mathJaxCdnUrl: string | undefined,\n  playerCatalog: PlayerCatalog,\n  itemCatalog: ItemCatalog\n  ) : Promise<void[]> \n{ \n  return Promise.all(\n      assessmentConfiguration.tasks\n        .map((taskConfiguration) => taskConfiguration.item)\n        .filter(onlyUnique)\n        .filter((itemName) => !itemCatalog.isRegistered(itemName))\n        .map((itemName) => installItem(itemName, mathJaxCdnUrl, playerCatalog, itemCatalog))\n  ); \n}\n\n/**\n * Is the given index the first occurrence of the given value in the given array?\n * \n * Using this method in a filter on an array will drop out all duplicates. \n */\n function onlyUnique<T>(value: T, index: number, all: T[]) : boolean {\n  return all.indexOf(value) === index;\n}\n\n/**\n * Build a promise that downloads the configuration for the item with the given name and installs it in the CBA runtime.\n */\nfunction installItem(\n  itemName: string, \n  mathJaxCdnUrl: string | undefined, \n  playerCatalog: PlayerCatalog, \n  itemCatalog: ItemCatalog) : Promise<void> {\n  const itemRootPathPrefix = `../items/${itemName}`;\n\n  return downloadItemConfig(itemName)\n    .then((itemConfiguration) => {\n      itemCatalog.register(itemConfiguration.name, itemConfiguration.runtimeCompatibilityVersion);\n      playerCatalog.doToAllCompatible(itemConfiguration.runtimeCompatibilityVersion, (targetWindow) => sendMessageToTaskPlayer(targetWindow, {\n        eventType: 'addItem', \n        itemConfig: itemConfiguration, \n        resourcePath: `${itemRootPathPrefix}/resources`,\n        externalResourcePath: `${itemRootPathPrefix}/external-resources`,\n        libraryPathsMap: { MathJax: mathJaxCdnUrl === undefined ? 'math-jax unknown' : mathJaxCdnUrl}\n      }));\n    })\n    .catch((error) => {\n      throw new Error(`Could not download configuration for item ${itemName}: ${error.message}`);\n    })\n}\n\n\n/**\n * Start the given task on a compatible player and make the player visible.\n */\nfunction findCompatiblePlayerAndStartTask(\n  startAdvice: { firstTask: TaskIdentification, playerId? : string},\n  playerCatalog: PlayerCatalog, \n  itemCatalog: ItemCatalog\n) : void \n{\n  const itemVersion = itemCatalog.getVersion(startAdvice.firstTask.item);\n  if (itemVersion === undefined) {\n    throw new Error(`Could not find item ${startAdvice.firstTask.item}.`);\n  }\n\n  const compatiblePlayer = getCompatiblePlayer(startAdvice.playerId, itemVersion, undefined, playerCatalog);\n  if (compatiblePlayer === undefined) {\n    throw new Error(`Could not find compatible player for item ${startAdvice.firstTask.item} with version ${itemVersion}.`);\n  }\n\n  playerCatalog.show(compatiblePlayer.id);\n  startTask(startAdvice.firstTask, compatiblePlayer.frameWindow);\n}\n\n/**\n * Do the initial steps once the task player is ready: \n *  - Assign a trace context id.\n *  - Configure the transmission channel for the trace log data.\n *  - Show a login box.\n */\n\n\n function initializeSessionAndShowLogin(\n   targetWindow: MessageEventSource, \n   logTransmissionConfig: LogTransmissionConfiguration | undefined, \n   playerCatalog: PlayerCatalog) {\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setTraceContextId', contextId: buildTraceContextId()});\n  \n  // If no log transmission channel is configured we simply keep the default (i.e. log to console)\n  if (logTransmissionConfig !== undefined) {\n    sendMessageToTaskPlayer(targetWindow, {\n      eventType: 'setTraceLogTransmissionChannel', \n      channel: 'http', interval: logTransmissionConfig.interval, \n      httpTimeout: logTransmissionConfig.httpTimeout, \n      transmitUrl: logTransmissionConfig.transmitUrl })\n  }\n  else{\n    sendMessageToTaskPlayer(targetWindow, {\n      eventType: 'setTraceLogTransmissionChannel', \n      channel: 'postMessage', \n      interval: 5000,\n      targetOrigin: '*', \n      targetWindowType: \"parent\"});\n  }\n  \n  if (playerCatalog.allPlayersReady()) {\n    const targetPlayer = playerCatalog.getPlayerId(targetWindow);\n    if (targetPlayer === undefined) {\n      console.warn(`Received ready request from unknown task player frame. This is an internal error. The initial login dialog might be unstable.`);\n    } else {\n      playerCatalog.show(targetPlayer);\n    }\n    showLogin(targetWindow);\n  }\n}\n\n\n/**\n* Establish ourselves as task sequencer in CBA runtime.\n */\nfunction setScalingConfiguration(targetWindow: MessageEventSource, sc :ScalingConfiguration) {\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setScalingConfiguration', ...sc})\n}\n\n/**\n* Establish ourselves as task sequencer in CBA runtime.\n */\nfunction setTaskSequencer(targetWindow: MessageEventSource) {\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setTaskSequencer', targetOrigin: window.location.origin, targetWindowType: 'parent'})\n}\n\n/**\n * Stop the running task in the CBA runtime.\n */\nfunction stopTask(targetWindow: MessageEventSource) : void {\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'stopTask'});\n}\n\n/**\n * Start a task in the CBA runtime.\n */\nfunction startTask(toStart: TaskIdentification, targetWindow: MessageEventSource) : void {\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'startTask', item: toStart.item, task: toStart.task, scope: toStart.scope});\n}\n\n/**\n * Request scoring result.\n */\nfunction getScoringResult(targetWindow: MessageEventSource) : void {\n  sendMessageToTaskPlayer(targetWindow, { eventType: 'getScoringResult'});\n}\n\n/**\n * Set the user ID in the CBA runtime.\n */\n function setUserId(userId: string, targetWindow: MessageEventSource) : void {\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setUserId', id: userId});\n}\n\n/**\n * Log out the current user.\n */\nfunction logout(targetWindow: MessageEventSource) : void {\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'logout'});\n}\n\n/**\n * Trigger the login box in the CBA runtime.\n */\nfunction showLogin(targetWindow: MessageEventSource, ) {\n  sendMessageToTaskPlayer(targetWindow, {eventType: \"showLogin\", titleLabel: \"Placeholder for Login\", fieldLabel: \"Please enter anything (nickname) \", buttonLabel: \"Start\" });\n}\n\n/**\n * Build a unique trace context id. \n */\nfunction buildTraceContextId() : string {\n  return v4();\n}\n\n/**\n * Get the id of a compatible player.\n * \n * Return the advised player if that exists and is compatible. \n * Otherwise return the player of the sending window if that is given and is compatible. \n * Otherwise pick any compatible task player.\n * \n * We return undefined if no compatible task player is registered.\n */\nfunction getCompatiblePlayer(\n  advisedPlayerId: string | undefined, \n  itemVersion: string,\n  sendingPlayer: { id: string, frameWindow: MessageEventSource} | undefined, \n  playerCatalog: PlayerCatalog) \n  : { id: string, frameWindow: MessageEventSource } | undefined \n{\n  \n  if (advisedPlayerId !== undefined && playerCatalog.isCompatibleById(itemVersion, advisedPlayerId)) {\n    const frameWindow = playerCatalog.getFrameWindow(advisedPlayerId);\n    if (frameWindow === undefined) {\n      console.error(`Unexpected failure to find frame for registered player ${advisedPlayerId}. We try to find another compatible one.`);\n    } else {\n      return { id: advisedPlayerId, frameWindow: frameWindow };\n    }\n  }\n\n  if (sendingPlayer !== undefined && playerCatalog.isCompatibleById(itemVersion, sendingPlayer.id)) {\n    return sendingPlayer;\n  }\n\n  const someCompatiblePlayer = playerCatalog.findCompatiblePlayer(itemVersion);\n  return someCompatiblePlayer === undefined ? undefined : { id: someCompatiblePlayer.id, frameWindow: someCompatiblePlayer.frameWindow };\n}\n\n\n/**\n * Get the advised player if that is given and registered.\n * Otherwise return the given triggering player. \n */\nfunction getTargetPlayer(\n    advisedPlayerId: string | undefined, \n    sendingPlayerId: string, \n    sendingWindow: MessageEventSource, \n    playerCatalog: PlayerCatalog) \n    : { id: string, frameWindow:MessageEventSource } \n{\n  if (advisedPlayerId === undefined) {\n    return { id: sendingPlayerId, frameWindow: sendingWindow };\n  }\n\n  const advisedFrame = playerCatalog.getFrameWindow(advisedPlayerId);\n  if (advisedFrame === undefined) {\n    console.log(`Advised player for request is not regitered. We use the triggering player instead.`);\n    return { id: sendingPlayerId, frameWindow: sendingWindow }\n  }\n\n  return { id: advisedPlayerId, frameWindow: advisedFrame}\n}\n\n\n","import {AssessmentConfiguration} from \"../utils/FileDownload\"\nimport { TaskRequestDetails } from \"./MessageReceiver\";\nimport { TaskIdentification } from \"../utils/FileDownload\";\nimport PlayerCatalog from \"../runtime/PlayerCatalog\";\n\n/**\n * The component making all next/previous/cancel task decisions. \n * \n * We keep a memory of available tasks and the currently running task. \n * This implementation does not take the task player instances into account\n * and does not advise on the next task player to use.\n * \n * With no task player advice the controller\n * sticks to the task player which was used before\n * (if the player is able to run the requested item)\n * or picks some other compatible player. \n */\nexport default class TaskSequencer {\n  private currentTaskIndex : number | 'not set' = 'not set';\n  private tasks : TaskIdentification[] = [];\n\n  public initialize(assessmentConfiguration: AssessmentConfiguration, playerCatalog: PlayerCatalog) : void {\n    this.currentTaskIndex = 0;\n    this.tasks = assessmentConfiguration.tasks;\n  }\n\n  public firstTask() : { firstTask: TaskIdentification, playerId?: string } | undefined {\n    this.currentTaskIndex = 0;\n    return this.tasks.length < 1 ? undefined : { firstTask: this.tasks[0] };\n  }\n\n  public cancel(sendingPlayerId: string) : Decision {\n    return { type: 'login'};\n  }\n\n  public nextTask(sendingPlayerId: string) : Decision {\n    return this.switchAndReturnTask((currentIndex) => currentIndex + 1, 'no next task');\n  }\n\n  public backTask(sendingPlayerId: string) : Decision {\n    return this.switchAndReturnTask((currentIndex) => currentIndex - 1, 'no previous task');\n  }\n\n  public goToTask(sendingPlayerId: string, request: TaskRequestDetails) : Decision {\n    return this.switchAndReturnTask(\n      (_) => this.findMatchingTask(request),\n      `Task ${request.task} ${request.item === undefined ? 'with item unspecified' : ('in item ' + request.item)} and in scope ${request.scope} is not part of the assessment configuration.`);\n  }\n\n  /**\n   * Calculate the index to pick using the callback, check that it is in range, switch to that task and return it. \n   */\n  private switchAndReturnTask(getIndexToPick: (currentIndex : number) => number, failureMessage: string ) : Decision {\n    if (this.currentTaskIndex === 'not set') {\n      console.warn(`Task sequencer is not initialized properly. This blocks all task switches.`);\n      return { type: 'blocked', reason: 'Task sequencer not initialized properly.' };\n    }\n    const indexToPick = getIndexToPick(this.currentTaskIndex);\n    if (indexToPick < 0 || indexToPick > this.tasks.length - 1) return { type: 'blocked', reason: failureMessage };\n    this.currentTaskIndex = indexToPick;\n    return { type: 'taskSwitch', nextTask: this.tasks[this.currentTaskIndex]};\n  }\n\n  private findMatchingTask(request: TaskRequestDetails) : number {\n    if (!request.item) return this.tasks.findIndex((candidate) => request.task === candidate.task && request.scope === candidate.scope)\n    return this.tasks.findIndex((candidate) => request.item === candidate.item && request.task === candidate.task && request.scope === candidate.scope)\n  }\n  \n}\n\n\n/**\n * The decision returned at the requests like cancel, nextTask etc.\n */\nexport type Decision = \n  { \n    type: 'login',\n    playerId?: string\n  } | \n  {\n    type: 'taskSwitch',\n    nextTask: TaskIdentification,\n    playerId?: string\n  } | \n  {\n    type: 'blocked'\n    reason: string\n  }\n\n\n","/**\n * The component managing all available task players (i.e. the available CBA runtimes in the player frames).\n * \n * The application established multiple CBA runtimes (with different runtime versions).\n * Each CBA runtime lives in its own IFrame and runs a task player.\n * \n * This catalog keeps track of all available task players. \n * \n * Each task player instance: \n *  - Is identified by a unique id string.\n *  - Runs in a frame with a frame window that should be used to send messages to the task player instance.\n */\nexport default class PlayerCatalog {\n  private readonly totalPlayerCount : number;\n  private readonly players : PlayerInfo[] = [];\n  private readonly pendingReadySignals : Set<MessageEventSource> = new Set<MessageEventSource>();  \n\n\n  // ------------ public interface -----------------------------------------------\n\n  /**\n   * Build the player catalog. \n   * \n   * We need the final total count of task players a priori:\n   * The controller should wait with the first login until all task players are ready \n   * to receive messages. We determine whether all task players are registered already\n   * by comparing with this total number of expected task players. \n   * \n   * @param totalPlayerCount The total number of task players that will register. \n   */\n  constructor(totalPlayerCount: number) {\n    this.totalPlayerCount = totalPlayerCount;\n  }\n\n  /**\n   * Register a new task player instance in our catalog.\n   * \n   * We implicitly set the is-ready flag for the task player\n   * if we already received its ready message earlier.\n   */\n  public registerPlayer(\n    id: string, \n    frameWindow: MessageEventSource, \n    frameRef: React.MutableRefObject<HTMLIFrameElement|null>, \n    compatibilityChecker: (itemVersion: string) => boolean\n    ) : void \n  {\n    const newPlayer = {id, frameWindow, frameRef, isCompatible: compatibilityChecker, readyFlag: false};\n    this.players.push(newPlayer);\n    this.applyPendingReadySignal(newPlayer);\n    if (this.totalPlayerCount < this.players.length) {\n      console.warn(`Unexpected registration of another task player ${id} as number ${this.players.length}. Check the total player count: ${this.totalPlayerCount}. We might have started the first login prematurely!`)\n    }\n\n    console.info(`Registered player ${id}`);\n  }\n\n\n  /**\n   * Process an incoming is-ready message from a task player instance.\n   * \n   * If the task player instance is already registered we set its ready flag. \n   * Otherwise we memorize the message and apply it once the task player instance is registered.\n   */\n  public receiveReadySignal(sourceWindow: MessageEventSource) : void {\n    const receivingPlayer = this.findPlayerByWindow(sourceWindow);\n    if (receivingPlayer === undefined) {\n      this.pendingReadySignals.add(sourceWindow);\n    } else {\n      receivingPlayer.readyFlag = true;\n    }\n  }\n\n  /**\n   * Are all task players ready to receive messages?\n   */\n   public allPlayersReady() : boolean {\n    return this.players.length >= this.totalPlayerCount && this.players.every(candidate => candidate.readyFlag);\n  }\n\n  /**\n   * Get the window of the frame where the task player with the given id is running.\n   * \n   * This window may be used to send messages to the task player instance.\n   *    \n   * We return undefined if no task player instance is registered for the given id.\n   */\n  public getFrameWindow(playerId: string) : MessageEventSource | undefined {\n    return this.findPlayerById(playerId)?.frameWindow;\n  }\n\n\n  /**\n   * Get the id of the task player instance running in the given frame window.\n   * \n   * We return undefined if no task player instance is registered for the given frame window.\n   */\n   public getPlayerId(sourceWindow: MessageEventSource) : string | undefined {\n    return this.findPlayerByWindow(sourceWindow)?.id;\n  }\n\n  /**\n   * Find a player that is compatible with the given item version. \n   * \n   * We return undefined if no such player is registered. \n   * If there is more than one compatbile player we return the first one\n   * in registration order.\n   */\n  public findCompatiblePlayer(itemVersion: string) : { id: string, frameWindow: MessageEventSource } | undefined {\n    return this.players.find(candidate => candidate.isCompatible(itemVersion));\n  }\n\n  /**\n   * Determine whether the given item version is compatible with the given task player instance.\n   * \n   * We return false if no task player for the given id is registered.\n   */\n  public isCompatibleById(itemVersion: string, playerId: string) : boolean | undefined {\n    const playerInfo = this.findPlayerById(playerId);\n    return playerInfo !== undefined && playerInfo.isCompatible(itemVersion);\n  } \n\n  /**\n   * Determine whether the given item version is compatible with the given task player instance.\n   * \n   * We return false if no task player for the given window is registered.\n   */\n  public isCompatibleByWindow(itemVersion: string, targetWindow: MessageEventSource) : boolean | undefined {\n    const playerInfo = this.findPlayerByWindow(targetWindow);\n      return playerInfo !== undefined && playerInfo.isCompatible(itemVersion);\n  } \n  \n  /**\n   * Run the given action on all registered task players.\n   */\n  public doToAll(action: (targetWindow: MessageEventSource) => void) {\n    this.players.forEach(player => action(player.frameWindow));\n  }\n\n  /**\n   * Run the given action on all registered and compatible task players.\n   */\n   public doToAllCompatible(itemVersion: string, action: (targetWindow: MessageEventSource) => void) {\n    this.players.filter(player => player.isCompatible(itemVersion)).forEach(player => action(player.frameWindow));\n  }\n\n\n  /**\n   * Make the given player visible to the user (i.e. make its Iframe visible).\n   */\n  public show(playerId: string) : void {\n    this.players.forEach(player => {\n      const frame : HTMLIFrameElement | null = player.frameRef.current;\n      if (frame === null) {\n        console.warn(`Cannot switch visibility for player ${player.id} since frame element is null.`);\n        return;\n      }\n      frame.style.visibility = player.id === playerId ? 'visible' : 'collapse';\n    })\n  }\n\n  /**\n   * Get the ids of all registered task players.\n   */\n  public getPlayerIds() : string[] {\n    return this.players.map(player => player.id);\n  }\n\n  // ------------ private methods ----------------------------------------------\n\n  /**\n   * Apply a pending is-ready message for the given player instance and \n   * drop it from the pending list. \n   * \n   * We do nothing if no is-ready message is on the pending list\n   * for the given task player instance.\n   */\n  private applyPendingReadySignal(player: PlayerInfo) : void {\n    const playerWindow : MessageEventSource = player.frameWindow;\n    if (this.pendingReadySignals.has(playerWindow)) {\n      player.readyFlag = true;\n      this.pendingReadySignals.delete(playerWindow);\n    }\n  }\n\n  /**\n   * Find the task player instance info for the given task player frame window.\n   */\n  private findPlayerByWindow(frameWindow: MessageEventSource) : PlayerInfo | undefined {\n    return this.players.find(candidate => candidate.frameWindow === frameWindow)\n  }\n\n  /**\n   * Find the task player instance info for the given task player id.\n   */\n   private findPlayerById(playerId: String) : PlayerInfo | undefined {\n    return this.players.find(candidate => candidate.id === playerId)\n  }\n\n}\n\n/**\n * Information about a task player in the task player catalog.\n */\n interface PlayerInfo {\n  id: string,\n  frameWindow: MessageEventSource,\n  frameRef: React.MutableRefObject<HTMLIFrameElement|null>\n  readyFlag: boolean,\n  isCompatible: (itemVersion: string) => boolean,\n}\n","/**\n * The component managing all items that were downloaded already. \n * \n * Each item is identified by its unique name string.\n * We keep the version number for each item.\n */\nexport default class ItemCatalog {\n  private items : ItemInfo[] = [];\n\n  /**\n   * Register an item in the catalog.\n   */\n  public register(name: string, version: string) : void {\n    this.items.push({name: name, version: version});\n  }\n\n  /**\n   * Is an item with the given name already registered in the catalog?\n   */\n  public isRegistered(name: string) : boolean {\n    return this.findByName(name) !== undefined;\n  }\n\n  /**\n   * Get the runtime version of an item.\n   * \n   * We return undefined if no item with the given name was already registered.\n   */\n  public getVersion(name: string) : string | undefined {\n    return this.findByName(name)?.version;\n  }\n\n  /**\n   * Private helper: Find an item in the catalog.\n   */\n  private findByName(name: string) : ItemInfo | undefined {\n    return this.items.find(candidate => candidate.name === name);\n  }\n\n}\n\n/**\n * Internal item representation in the catalog.\n */\ninterface ItemInfo {\n  name: string, \n  version: string\n}\n\n\n","import React, { useEffect } from 'react';\nimport { PlayerConfiguration } from '../utils/FileDownload';\nimport PlayerCatalog from './PlayerCatalog';\n\n/**\n * An IFrame containing a CBA runtime running a task player.\n * \n * The component registers the task player as soon as the IFrame \n * is available. \n * \n * The properties itemWidth and itemHeight specify the size of the IFrame.\n * We load the source file for the IFrame from the react-runtime subfolder.\n */\nexport default function PlayerFrame( props: {\n    itemWidth: number, \n    itemHeight: number,\n    showPlayerInfo: boolean,\n    playerConfiguration: PlayerConfiguration,\n    playerCatalog: PlayerCatalog\n  }) : JSX.Element\n{\n\n  const { playerId, runtimeVersion, frameContentFile } = props.playerConfiguration;\n\n  // The late-binding references to the CBA-runtime IFrame element and the containing div element:\n  const frameRef: React.MutableRefObject<HTMLIFrameElement|null> = React.useRef(null);\n  const divRef: React.MutableRefObject<HTMLIFrameElement|null> = React.useRef(null);\n \n\n  // Once our frame is mounted register the player in the player catalog:\n  useEffect(() => {\n    const contentWindow = frameRef.current?.contentWindow;\n    if (contentWindow === null || contentWindow === undefined) {\n      console.warn(`Content window of task player frame is invalid!`);\n      return;\n    }\n    props.playerCatalog.registerPlayer(playerId, contentWindow, divRef, (itemVersion) => itemVersion === runtimeVersion);\n  }, [props.playerCatalog, playerId, runtimeVersion]);\n\n  return (\n    <div className='PlayerFrame' \n      ref={divRef}\n      style={{position: 'absolute', top: '0px', left: '0px', borderStyle: 'none', width: '100%', height: '100%', display: 'flex', alignItems: 'baseline', justifyContent: 'center'}}\n    >\n      { !props.showPlayerInfo || \n        <div style={{fontSize: 'xx-small' }}>\n          Current Player: {playerId }, Version: {runtimeVersion}\n        </div>\n      }\n      <iframe\n        ref={frameRef}\n        style={\n          { \n            width: '100%',\n            height: '100%'\n            // width: props.itemWidth + 'px',\n            // height: props.itemHeight + 'px'\n          }\n        }\n        title='PlayerFrame'\n        src={`./react-runtime/${frameContentFile}?eventTargetWindow=parent`}       \n        frameBorder=\"0\"  \n        scrolling=\"no\"  \n        className='cbaframe'\n      />\n    </div>\n  )\n}\n\n","import React from 'react';\nimport './App.css';\nimport MessageReceiver from './MessageReceiver';\nimport { configureMessageReceiver } from './Controller';\nimport TaskSequencer from './TaskSequencer';\nimport PlayerCatalog from '../runtime/PlayerCatalog';\nimport ItemCatalog from '../runtime/ItemCatalog';\nimport { ControllerConfiguration } from '../utils/FileDownload';\nimport PlayerFrame from '../runtime/PlayerFrame';\n\n/**\n * The layer that sets up all components: \n *  - The catalogs of items and task players.\n *  - The task sequencer.\n *  - The listeners in the message receiver.\n *  - The IFrames that contain the CBA runtimes with different runtime versions.\n * \n * The 'controller' is not a component (for now). \n * It is implemented as a set of listeners registered\n * in the message receiver.\n */\nexport function App(props: { messageReceiver : MessageReceiver, controllerConfiguration: ControllerConfiguration}) : JSX.Element {\n\n  const { messageReceiver, controllerConfiguration } = props;\n\n  // All task players that we support.\n  const playersArray = controllerConfiguration.players;\n\n  // The catalog of all the task players running in their Iframes:\n  const playerCatalog : PlayerCatalog = new PlayerCatalog(playersArray.length);\n\n  // The catalog of all items that are currently loaded to all compatible the task players:\n  const itemCatalog : ItemCatalog = new ItemCatalog();\n\n  // The task sequencer that decides which task to run next:\n  const taskSequencer : TaskSequencer = new TaskSequencer();\n\n  // Establish our behavior, i.e. our reactions to events coming in from the task players:\n  configureMessageReceiver(\n    messageReceiver, \n    taskSequencer, \n    playerCatalog, \n    itemCatalog, \n    controllerConfiguration);\n  \n  const itemHeight = controllerConfiguration.itemSize === undefined ? 768 : controllerConfiguration.itemSize.height;\n  const itemWidth = controllerConfiguration.itemSize === undefined ? 1024 : controllerConfiguration.itemSize.width;\n\n  return (\n    <div className='App' >\n      { playersArray.map(player => \n        <PlayerFrame\n          key={player.playerId}\n          itemWidth={itemWidth} \n          itemHeight={itemHeight}\n          showPlayerInfo = {controllerConfiguration.showPlayerInfo}\n          playerConfiguration = {player}\n          playerCatalog={playerCatalog}\n        />\n        )\n      }      \n    </div>\n  );\n}\n\n\n\n/**\n * Create and initialize the message receiver.\n * \n * We start its receiving loop on the global window.\n * \n * We create the message receiver outside of ReactDOM.render \n * to make sure it is not created multiple times\n * which would lead to multiple listeners on the global window.\n * \n */\nexport function buildMessageReceiver() : MessageReceiver {\n  const result = new MessageReceiver();\n  result.startReceiving();\n  return result;\n}\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport {App, buildMessageReceiver} from './controller/App';\nimport { ControllerConfiguration, downloadControllerConfig } from './utils/FileDownload';\n\n/**\n * The entry point into the application.\n */\n\n// We start the application rendering after fetching our controller configuration.\ndownloadControllerConfig()\n.then((controllerConfiguration: ControllerConfiguration) => {\n  // We create the message receiver here to make sure it is created exactly once:\n  const messageReceiver = buildMessageReceiver();\n  \n  ReactDOM.render(\n    <React.StrictMode>\n      <App messageReceiver={messageReceiver} controllerConfiguration={controllerConfiguration} />\n    </React.StrictMode>,\n    document.getElementById('ee4basicsRoot')\n  );  \n})\n.catch((error) => {\n  console.warn(`Could not initialize assessment properly: ${error.message}`);\n});\n"],"sourceRoot":""}