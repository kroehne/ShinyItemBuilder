{"version":3,"sources":["controller/MessageReceiver.tsx","controller/MessageSender.tsx","utils/FileDownload.tsx","controller/Controller.tsx","controller/TaskSequencer.tsx","runtime/PlayerCatalog.tsx","runtime/ItemCatalog.tsx","runtime/PlayerFrame.tsx","controller/App.tsx","index.tsx"],"names":["MessageReceiver","_classCallCheck","playerReadyListener","preloadReturnListener","getUserIdReturnListener","loginDialogClosedListener","getTaskReturnListener","getScoringResultReturnListener","traceLogListener","recordingListener","getTasksStateReturnListener","taskSwitchRequestListener","shinyTaskSwitchRequestListener","shinyPreloadStateListener","_createClass","key","value","_this","window","addEventListener","event","processMessageEvent","listener","this","origin","data","source","parent","dataObject","JSON","parse","e","console","info","concat","eventType","_dataObject$traceLogD","traceLogData","metaData","logEntriesList","log","stringify","map","entry","warn","_dataObject2","request","scope","item","task","undefined","_dataObject","userId","state","_dataObject$recording","recordingData","recordingEntriesList","result","fieldValue","id","isSuccess","message","type","sendMessageToTaskPlayer","targetWindow","payload","postMessage","targetOrigin","downloadAssessmentConfig","sendJsonDownloadRequest","then","response","candidate","tasks","Array","isArray","every","isTaskIdentification","error","isAssessmentConfiguration","Error","length","filename","Promise","resolve","reject","xhttp","XMLHttpRequest","responseType","onload","onerror","statusText","open","send","extractFromQuery","params","document","location","search","replace","split","forEach","a","tmp","indexOf","isPlayerConfiguration","playerId","runtimeVersion","frameContentFile","configureMessageReceiver","messageReceiver","taskSequencer","playerCatalog","itemCatalog","controllerConfig","setTaskSwitchRequestListener","sendingWindow","requestDetails","sendingPlayerId","getPlayerId","decision","cancel","nextTask","backTask","reason","goToTask","getNextAction","advisedPlayerId","targetPlayer","frameWindow","advisedFrame","getFrameWindow","getTargetPlayer","stopTask","doToAll","logout","show","showLogin","processLoginRequest","getScoringResult","setShinyTaskSwitchRequestListener","targetItemVersion","getVersion","compatiblePlayer","findCompatiblePlayer","startTask","processShinyTaskSwitchRequest","setShinyPreloadStateListener","_taskSequencer$firstT","firstTask","setLoginDialogClosedListener","nickname","setUserId","setTaskSequencer","configuration","initialize","loadItemsAndStartFirstTask","mathJaxCdnUrl","catch","setPlayerReadyListener","receiveReadySignal","channel","interval","targetWindowType","contextId","buildTraceContextId","_q","_extractFromQuery$q","q","extractUserIdFromQuery","sc","_objectSpread","setScalingConfiguration","scalingMode","alignmentHorizontal","alignmentVertical","assessmentConfiguration","all","taskConfiguration","filter","onlyUnique","itemName","isRegistered","itemRootPathPrefix","runtimeCompatibilityVersion","name","isItemConfiguration","downloadItemConfig","itemConfiguration","register","doToAllCompatible","itemConfig","resourcePath","externalResourcePath","libraryPathsMap","MathJax","installItem","installAllItems","playerCount","getPlayerIds","startAdvice","itemVersion","getCompatiblePlayer","findCompatiblePlayerAndStartTask","index","toStart","titleLabel","fieldLabel","buttonLabel","v4","sendingPlayer","isCompatibleById","someCompatiblePlayer","TaskSequencer","currentTaskIndex","switchAndReturnTask","currentIndex","_","findMatchingTask","getIndexToPick","failureMessage","indexToPick","findIndex","PlayerCatalog","totalPlayerCount","players","pendingReadySignals","Set","frameRef","compatibilityChecker","newPlayer","isCompatible","readyFlag","push","applyPendingReadySignal","sourceWindow","receivingPlayer","findPlayerByWindow","add","_this$findPlayerById","findPlayerById","_this$findPlayerByWin","find","playerInfo","action","player","frame","current","style","visibility","playerWindow","has","delete","ItemCatalog","items","version","findByName","_this$findByName","PlayerFrame","props","_props$playerConfigur","playerConfiguration","React","useRef","divRef","useEffect","_frameRef$current","contentWindow","registerPlayer","_jsxs","className","ref","position","top","left","borderStyle","width","height","display","alignItems","justifyContent","children","showPlayerInfo","fontSize","_jsx","title","src","frameBorder","scrolling","App","controllerConfiguration","playersArray","itemHeight","itemSize","itemWidth","traceLogTransmission","transmitUrl","httpTimeout","isLogTransmissionConfiguration","isControllerConfiguration","startReceiving","buildMessageReceiver","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.bd6d4ce4.chunk.js","sourcesContent":["import { PreloadResultStruct } from './PreloadResultStruct';\r\n\r\n/**\r\n * Service that receives messages from the task players \r\n * and delivers them to the configured listeners. \r\n * \r\n * All listeners are called with the frame window of the sending task player\r\n * (besides the specific message content).\r\n */\r\nexport default class MessageReceiver {\r\n  private playerReadyListener : ((source: MessageEventSource) => void) | 'noListener' = 'noListener'; \r\n  private preloadReturnListener : ((source: MessageEventSource, result : PreloadResultStruct) => void) | 'noListener' = 'noListener'; \r\n  private getUserIdReturnListener : ((source: MessageEventSource, result : string) => void) | 'noListener' = 'noListener'; \r\n  private loginDialogClosedListener : ((source: MessageEventSource, result : string) => void) | 'noListener' = 'noListener'; \r\n  private getTaskReturnListener : ((source: MessageEventSource, result: GetTaskReturn) => void) | 'noListener' = 'noListener'; \r\n  private getScoringResultReturnListener : ((source: MessageEventSource, result: string) => void) | 'noListener' = 'noListener'; \r\n  \r\n  private traceLogListener : ((source: MessageEventSource, metaData: string, logEntriesList: string[]) => void) | 'noListener' = 'noListener'; \r\n  private recordingListener : ((source: MessageEventSource, metaData: string, recordingEntriesList: string[]) => void) | 'noListener' = 'noListener'; \r\n  private getTasksStateReturnListener : ((source: MessageEventSource, userId: string, state: string) => void) | 'noListener' = 'noListener'; \r\n\r\n  private taskSwitchRequestListener : ((source: MessageEventSource, request: RequestType, requestDetails?: TaskRequestDetails) => void) | 'noListener' = 'noListener'; \r\n  \r\n  private shinyTaskSwitchRequestListener : ((source: MessageEventSource, requestDetails: ShinySwitchRequest) => void) | 'noListener' = 'noListener'; \r\n  private shinyPreloadStateListener : ((source: MessageEventSource, requestDetails: any) => void) | 'noListener' = 'noListener'; \r\n\r\n  /**\r\n   * Start to receive messages.\r\n   */\r\n  public startReceiving() {\r\n    window.addEventListener(\"message\", (event) => {\r\n      this.processMessageEvent(event);\r\n    })\r\n  \r\n  }\r\n  \r\n  public setPlayerReadyListener(listener: (source: MessageEventSource) => void) : void {\r\n    this.playerReadyListener = listener;\r\n  }\r\n\r\n  public setPreloadReturnListener(listener: (source: MessageEventSource, result : PreloadResultStruct) => void) : void {\r\n    this.preloadReturnListener = listener;\r\n  }\r\n\r\n  public setGetUserIdReturnListener(listener: (source: MessageEventSource, result : string) => void) : void {\r\n    this.getUserIdReturnListener = listener;\r\n  }\r\n\r\n  public setLoginDialogClosedListener(listener: (source: MessageEventSource, result : string) => void) : void {\r\n    this.loginDialogClosedListener = listener;\r\n  }\r\n\r\n  public setGetTaskReturnListener(listener: (source: MessageEventSource, result: GetTaskReturn) => void) : void {\r\n    this.getTaskReturnListener = listener;\r\n  }\r\n\r\n  public setGetScoringResultReturnListener(listener: (source: MessageEventSource, result: string) => void) : void {\r\n    this.getScoringResultReturnListener = listener;\r\n  }\r\n\r\n  public setTraceLogListener(listener: (source: MessageEventSource, metaData: string, logEntriesList: string[]) => void) : void {\r\n    this.traceLogListener = listener;\r\n  }\r\n\r\n  public setRecordingListener(listener: (source: MessageEventSource, metaData: string, recordingEntriesList: string[]) => void) : void {\r\n    this.recordingListener = listener;\r\n  }\r\n\r\n  public setGetTasksStateReturnListener(listener: (source: MessageEventSource, userId: string, state: string) => void) : void {\r\n    this.getTasksStateReturnListener = listener;\r\n  }\r\n\r\n  public setTaskSwitchRequestListener(listener: (source: MessageEventSource, request: RequestType, requestDetails?: TaskRequestDetails) => void) : void {\r\n    this.taskSwitchRequestListener = listener;\r\n  }\r\n\r\n  public setShinyTaskSwitchRequestListener(listener: (source: MessageEventSource, requestDetails: ShinySwitchRequest) => void) : void {\r\n    this.shinyTaskSwitchRequestListener = listener;\r\n  }\r\n\r\n  public setShinyPreloadStateListener(listener: (source: MessageEventSource, requestDetails: any) => void) : void {\r\n    this.shinyPreloadStateListener = listener;\r\n  }\r\n\r\n  private processMessageEvent(event : MessageEvent<any>) : void {\r\n    const { origin, data, source } = event;\r\n\r\n    if (source === null) {\r\n      console.warn(`Ignoring message without source.`);\r\n      return;\r\n    }\r\n\r\n    if (origin !== window.origin) {\r\n      console.warn(`Ignoring message from wrong origin. Message origin is ${origin}. Accepted origin is ${window.origin}.`);\r\n      return;\r\n    }\r\n\r\n    //assume it's a PM from shiny\r\n    if(source === window.parent && typeof data === \"object\"){\r\n      // console.log(data);\r\n      if(!data.type)\r\n        return;\r\n\r\n      if(data.type === \"navigate_to\" && this.shinyTaskSwitchRequestListener !== \"noListener\"){\r\n        this.shinyTaskSwitchRequestListener(source, data.request as ShinySwitchRequest);\r\n      }\r\n\r\n      else if(data.type === \"preload_state\" && this.shinyPreloadStateListener !== \"noListener\"){\r\n        this.shinyPreloadStateListener(source, data.request);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n\r\n    let dataObject;\r\n    try {\r\n      dataObject = JSON.parse(data);\r\n    } catch (e) {\r\n      console.info(`Ignoring message with non-JSON data: ${data}`);\r\n      return;\r\n    }\r\n\r\n    const eventType = dataObject.eventType;\r\n\r\n    if (eventType === 'taskPlayerReady' && this.playerReadyListener !== 'noListener') {\r\n      this.playerReadyListener(source);\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'setPreloadReturn' && this.preloadReturnListener !== 'noListener') {\r\n      const result : PreloadResultStruct = { isSuccess: dataObject.isSuccess, message: dataObject.message };\r\n      this.preloadReturnListener(source, result);\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'getUserIdReturn' && this.getUserIdReturnListener !== 'noListener') {\r\n      this.getUserIdReturnListener(source, dataObject.id);\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'loginDialogClosed' && this.loginDialogClosedListener !== 'noListener') {\r\n      this.loginDialogClosedListener(source, dataObject.fieldValue);\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'getTaskReturn' && this.getTaskReturnListener !== 'noListener') {\r\n      this.getTaskReturnListener(source, {scope: dataObject.scope, item: dataObject.item, task: dataObject.task});\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'getScoringResultReturn' && this.getScoringResultReturnListener !== 'noListener') {\r\n      this.getScoringResultReturnListener(source, JSON.stringify(dataObject.result));\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'traceLogTransmission' && this.traceLogListener !== 'noListener') {\r\n      const {metaData, logEntriesList} = dataObject.traceLogData;\r\n      console.log(dataObject.traceLogData);\r\n      this.traceLogListener(source, JSON.stringify(metaData), logEntriesList.map((entry : object) => JSON.stringify(entry)));\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'recordingTransmission' && this.recordingListener !== 'noListener') {\r\n      const {metaData, recordingEntriesList} = dataObject.recordingData;\r\n      this.recordingListener(source, JSON.stringify(metaData), recordingEntriesList.map((entry : object) => JSON.stringify(entry)));\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'getTasksStateReturn' && this.getTasksStateReturnListener !== 'noListener') {\r\n      const {userId, state} = dataObject;\r\n      this.getTasksStateReturnListener(source, userId, JSON.stringify(state));\r\n      return;\r\n    }\r\n\r\n    if (eventType === 'taskSwitchRequest' && this.taskSwitchRequestListener !== 'noListener') {\r\n      const {request, scope, item, task} = dataObject;\r\n      this.taskSwitchRequestListener(source, request, request === 'goToTask' ? {scope, item, task} : undefined);\r\n      return;\r\n    }\r\n\r\n    console.warn(`Ignoring message not matching any listener: ${data}`)\r\n\r\n  }\r\n\r\n  private processShinyMessage(data : any){\r\n    console.log(data);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Structures describing a task switch request:\r\n */\r\nexport type RequestType = 'nextTask' | 'previousTask' | 'cancelTask' | 'goToTask';\r\n\r\nexport interface TaskRequestDetails {\r\n  item?: string, \r\n  task: string, \r\n  scope: string\r\n}\r\n\r\nexport interface GetTaskReturn {\r\n  item: string, \r\n  task?: string, \r\n  scope: string\r\n}\r\n\r\nexport interface ShinySwitchRequest {\r\n  item: string, \r\n  runtime: string, \r\n  task: string,\r\n  scope?: string\r\n}\r\n","/**\r\n * Send a message to the TaskPlayer running in the given target window.\r\n * \r\n * This method covers all messages defined by the TaskPlayer API\r\n * (even though we currently do not use all of them).\r\n */\r\nexport function sendMessageToTaskPlayer(targetWindow : MessageEventSource, payload : \r\n    // configuration control\r\n    { eventType: 'setWaitMessages', primary: string, secondary: string} | \r\n    { eventType: 'addItem', itemConfig: object, resourcePath: string, externalResourcePath: string, libraryPathsMap: {MathJax: string} } |\r\n    { eventType: 'clearItems'} |\r\n    { eventType: 'setPreload', itemName: string} |\r\n    // trace control\r\n    { eventType: 'insertMessageInTrace', message: string} |\r\n    { eventType: 'logStateToTrace'} |\r\n    { eventType: 'flushTrace'} |\r\n    { eventType: 'setTraceLogTransmissionChannel', channel: 'postMessage', targetWindowType?: string, targetOrigin?: string, interval: number} |\r\n    { eventType: 'setTraceLogTransmissionChannel', channel: 'http',  transmitUrl?: string,  interval: number,  httpTimeout?: number} |\r\n    { eventType: 'setTraceLogTransmissionChannel', channel: 'console',  interval: number} |\r\n    { eventType: 'setTraceContextId', contextId: string} |\r\n    // recordings control \r\n    { eventType: 'setRecordingTransmissionChannel', channel: 'http', transmitUrl: string, httpTimeout: number} |\r\n    { eventType: 'setRecordingTransmissionChannel', channel: 'console'} |\r\n    { eventType: 'setRecordingContextId', contextId: string} |\r\n    // user control\r\n    { eventType: 'setUserId', id: string} |\r\n    { eventType: 'logout'} |\r\n    { eventType: 'getUserId'} |\r\n    { eventType: 'showLogin', titleLabel: string, fieldLabel: string, buttonLabel: string} |\r\n    // task control\r\n    { eventType: 'startTask', scope: string, item: string, task: string} |\r\n    { eventType: 'stopTask'} |\r\n    { eventType: 'pauseTask' } |\r\n    { eventType: 'resumeTask' } |\r\n    { eventType: 'getTask' } |\r\n    { eventType: 'setTaskSequencer', targetWindowType: 'parent', targetOrigin: string} |\r\n    { eventType: 'setSwitchAvailability', request: 'nextTask' | 'previousTask' | 'cancelTask', value: boolean} |\r\n    { eventType: 'setSwitchAvailability', request: 'goToTask', scope: string, item?: string, task: string, value: boolean} |\r\n    { eventType: 'setScalingConfiguration', scalingMode: string, alignmentHorizontal: string, alignmentVertical: string} | \r\n    // task state control\r\n    { eventType: 'getTasksState'} |\r\n    { eventType: 'clearTasksState' } |\r\n    { eventType: 'preloadTasksState', state: string } |\r\n    // scoring control\r\n    { eventType: 'getScoringResult'} |\r\n    // state machine control\r\n    { eventType: 'sendStatemachineEvent', event: string} |\r\n    // header control\r\n    { eventType: 'setHeaderButtons', headerButtons: HeaderButtonDescription[]} |\r\n    { eventType: 'setMenuCarousels', course: string[], scopes: HeaderMenuScopeDescription[]} |\r\n    // developer mode control\r\n    { eventType: 'activateDebuggingWindows', scoreHotKey: string, traceHotKey: string, statemachineHotKey: string}\r\n  ) \r\n{\r\n  targetWindow.postMessage(JSON.stringify(payload), { targetOrigin: '*'});\r\n}\r\n\r\n\r\nexport interface HeaderButtonDescription {\r\n  image?: string, \r\n  text: string,\r\n  event: string,\r\n  height: number,\r\n  width: number\r\n}\r\n\r\nexport interface HeaderMenuScopeDescription {\r\n  name: string, \r\n  tasks: {item: string, task: string}[]\r\n}","/**\r\n * Asynchronous methods that download files and provide their content as proper structures.\r\n */\r\n\r\n// ----------------- public API --------------------------------------------------------------\r\n\r\n/**\r\n * Return a promise that downloads the controller configuration.\r\n */\r\n export function downloadControllerConfig() : Promise<ControllerConfiguration> {\r\n  const fullConfigFileName = `./controller/config.json`;\r\n  return sendJsonDownloadRequest(fullConfigFileName).then(\r\n    (response) => {\r\n      if(!isControllerConfiguration(response)) {\r\n        throw new Error(`Controller configuration is invalid: ${JSON.stringify(response)}`);\r\n      }\r\n      console.log(`Received controller configuration`, response);\r\n      return response;\r\n    }\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * Return a promise that downloads the assessment configuration.\r\n */\r\nexport function downloadAssessmentConfig() : Promise<AssessmentConfiguration> {\r\n  const fullConfigFileName = `./assessments/config.json`;\r\n  return sendJsonDownloadRequest(fullConfigFileName).then(\r\n    (response) => {\r\n      if(!isAssessmentConfiguration(response)) {\r\n        throw new Error(`Assessment configuration is invalid: ${JSON.stringify(response)}`);\r\n      }\r\n      if (response.tasks.length < 1) {\r\n        throw new Error(`Assessment configuration contains no tasks: ${JSON.stringify(response)}`);\r\n      }\r\n      console.log(`Received assessment configuration`, response);\r\n      return response;\r\n    }\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * Return a promise that downloads the item configuration for the given item.\r\n *\r\n *  The corresponding *.json file must have this name with .json appended as extension.\r\n */\r\nexport function downloadItemConfig(itemName : string) : Promise<ItemConfiguration> {\r\n  const fullConfigFileName = `./items/${itemName}/config.json`;\r\n  return sendJsonDownloadRequest(fullConfigFileName).then(\r\n    (response) => {\r\n      if(!isItemConfiguration(response)) {\r\n        throw new Error(`Configuration of ${itemName} is invalid: ${JSON.stringify(response)}`);\r\n      }\r\n      console.log(`Received configuration of ${itemName}`, response);\r\n      return response;\r\n    }\r\n  );\r\n}\r\n\r\n\r\nexport function extractScalingConfigurationFromQuery() :ScalingConfiguration{\r\n  let sc :any = {scalingMode: \"scale-up-down\", alignmentHorizontal: \"center\", alignmentVertical: \"center\"};\r\n  return {...sc, ...extractFromQuery([\"scalingMode\", \"alignmentHorizontal\", \"alignmentVertical\"])};\r\n}\r\n\r\nexport function extractUserIdFromQuery(_q :string) :string{\r\n  let q = _q.length ? _q : \"session\";\r\n  return extractFromQuery([q])[q] ?? \"default\";\r\n}\r\n/**\r\n * The content of the assessment configuration file.\r\n */\r\nexport interface AssessmentConfiguration {\r\n  tasks: TaskIdentification[]\r\n}\r\n\r\nexport interface TaskIdentification {\r\n  item: string, \r\n  task: string, \r\n  scope: string\r\n}\r\n\r\n/**\r\n * The content of an item configuration file (as far as we need it).\r\n */\r\nexport interface ItemConfiguration {\r\n  runtimeCompatibilityVersion: string,\r\n  name: string\r\n}\r\n\r\n/**\r\n * The content of the controller configuration file.\r\n */\r\nexport interface ControllerConfiguration {\r\n  traceLogTransmission?: LogTransmissionConfiguration\r\n  mathJaxCdnUrl?: string,\r\n  itemSize?: {\r\n    height: number,\r\n    width: number\r\n  },\r\n  players: PlayerConfiguration[],\r\n  showPlayerInfo: boolean\r\n}\r\n\r\nexport interface LogTransmissionConfiguration {\r\n  transmitUrl: string,\r\n  interval: number, \r\n  httpTimeout: number, \r\n}\r\n\r\nexport interface PlayerConfiguration {\r\n  playerId: string,\r\n  runtimeVersion: string,\r\n  frameContentFile: string,\r\n}\r\n\r\nexport interface ScalingConfiguration {\r\n  scalingMode: string, \r\n  alignmentHorizontal: string, \r\n  alignmentVertical: string\r\n}\r\n\r\n\r\n// ----------------- private stuff --------------------------------------------------------------\r\n\r\n/**\r\n * Return a Promise that processes a GET request for the given file.\r\n */\r\nfunction sendJsonDownloadRequest(filename : string) : Promise<any> {\r\n  return new Promise((resolve, reject) => {\r\n    const xhttp = new XMLHttpRequest();\r\n    xhttp.responseType = 'json';\r\n    xhttp.onload = () => resolve(xhttp.response);\r\n    xhttp.onerror = () => reject(xhttp.statusText);\r\n    xhttp.open('GET', filename, true);\r\n    xhttp.send();\r\n  });\r\n}\r\n\r\nfunction extractFromQuery(params :Array<string>){\r\n  let result :any = {};\r\n  if(window.document.location.search.length){\r\n    try {\r\n      document.location.search\r\n      .replace('?', '')\r\n      .split('&')\r\n      .forEach((a) => {\r\n        let tmp = a.split('=');\r\n        if(tmp.length===2 && params.indexOf(tmp[0])>=0)\r\n          result[tmp[0]] = tmp[1];\r\n      });\r\n    } catch (error) {\r\n      console.error(\"error parsing query string: \" + error);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Runtime type checker for AssessmentConfiguration candidates.\r\n */\r\n function isAssessmentConfiguration(candidate: any) : candidate is AssessmentConfiguration {\r\n  try {\r\n    return candidate.tasks && Array.isArray(candidate.tasks) && candidate.tasks.every(isTaskIdentification); \r\n  }\r\n  catch(error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Runtime type checker for TaskIdentification candidates.\r\n */\r\nfunction isTaskIdentification(candidate: any) : candidate is TaskIdentification {  \r\n  try {\r\n    return (\r\n      candidate.item && typeof candidate.item === 'string' &&\r\n      candidate.task && typeof candidate.task === 'string' &&\r\n      candidate.scope && typeof candidate.scope === 'string' \r\n    );\r\n  }\r\n  catch(error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Runtime type checker for ItemConfiguration candidates.\r\n * \r\n * We just check some 'marker' members. \r\n */\r\n function isItemConfiguration(candidate: any) : candidate is ItemConfiguration {  \r\n  try {\r\n    return (\r\n      candidate.runtimeCompatibilityVersion && typeof candidate.runtimeCompatibilityVersion === 'string' &&\r\n      candidate.name && typeof candidate.name === 'string'\r\n    );\r\n  }\r\n  catch(error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Runtime type checker for ControllerConfiguration candidates.\r\n */\r\n function isControllerConfiguration(candidate: any) : candidate is ControllerConfiguration {  \r\n  try {\r\n    return (\r\n        candidate.traceLogTransmission === undefined || isLogTransmissionConfiguration(candidate.traceLogTransmission)\r\n      ) && (\r\n        candidate.mathJaxCdnUrl === undefined || \r\n        (\r\n          candidate.mathJaxCdnUrl && typeof candidate.mathJaxCdnUrl === 'string'\r\n        )      \r\n      ) && (\r\n        candidate.itemSize === undefined ||\r\n        (\r\n          candidate.itemSize.height && typeof candidate.itemSize.height === 'number' &&\r\n          candidate.itemSize.width && typeof candidate.itemSize.width === 'number'\r\n        )\r\n      ) && (\r\n        candidate.players && Array.isArray(candidate.players) && candidate.players.every(isPlayerConfiguration)\r\n      ) && (\r\n        typeof candidate.showPlayerInfo === 'boolean'\r\n      )\r\n      ;\r\n  }\r\n  catch(error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Runtime type checker for LogTransmissionConfiguration candidates.\r\n */\r\n function isLogTransmissionConfiguration(candidate: any) : candidate is LogTransmissionConfiguration {  \r\n  try {\r\n    return (\r\n          candidate.transmitUrl && typeof candidate.transmitUrl === 'string' &&\r\n          candidate.interval && typeof candidate.interval === 'number' &&\r\n          candidate.httpTimeout && typeof candidate.httpTimeout === 'number'\r\n    );\r\n  }\r\n  catch(error) {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Runtime type checker for PlayerConfiguration candidates.\r\n */\r\n function isPlayerConfiguration(candidate: any) : candidate is PlayerConfiguration {  \r\n  try {\r\n    return (\r\n      candidate.playerId && typeof candidate.playerId === 'string' &&\r\n      candidate.runtimeVersion && typeof candidate.runtimeVersion === 'string' &&\r\n      candidate.frameContentFile && typeof candidate.frameContentFile === 'string' \r\n    );\r\n  }\r\n  catch(error) {\r\n    return false;\r\n  }\r\n}\r\n","import { v4 } from 'uuid'; \r\nimport MessageReceiver, { TaskRequestDetails, RequestType, ShinySwitchRequest } from \"./MessageReceiver\";\r\nimport { sendMessageToTaskPlayer } from \"./MessageSender\";\r\nimport { \r\n  ControllerConfiguration, \r\n  LogTransmissionConfiguration, \r\n  AssessmentConfiguration, \r\n  downloadAssessmentConfig, \r\n  ScalingConfiguration,\r\n  extractScalingConfigurationFromQuery,\r\n  extractUserIdFromQuery,\r\n  downloadItemConfig,\r\n} from \"../utils/FileDownload\"; \r\nimport TaskSequencer, { Decision } from \"./TaskSequencer\";\r\nimport { TaskIdentification } from \"../utils/FileDownload\";\r\nimport PlayerCatalog from '../runtime/PlayerCatalog';\r\nimport ItemCatalog from '../runtime/ItemCatalog';\r\n\r\n/**\r\n * Controller coordinating actions required to run the tasks list in the available task players.\r\n * \r\n * The controller supports multiple task player instances running in different frames (to support\r\n * multiple CBA runtime versions). It gets access to these instances and their frames via a player catalog. \r\n * \r\n * All activity is triggered by the events coming in from the CBA runtimes once the task players have started there:\r\n * \r\n * The task-player-ready events coming in trigger configuration of the sending task player:\r\n *  - Set session ID (each player gets its own session ID).\r\n *  - Configure trace log transmission channel for the sending task player.\r\n * \r\n * The last task-player-ready event coming in also triggers the login phase:\r\n *  - Show login dialog in the sending task player.\r\n * \r\n * The login-done event triggers the initialization phase which ends with starting a first task:\r\n *  - Set the user ID for all available task players.\r\n *  - Download of configuration data and item data.\r\n *  - For each item not yet registered in the item catalog:\r\n *     * Register the item in the item catalog.\r\n *     * Determine the compatible task players and upload the item configuration there.\r\n *  - Establish a task sequencer.\r\n *  - Obtain the first task to run from the task sequencer and start it on the task player determined by the task sequencer. \r\n * \r\n * The task-switch-request events trigger task-switch responses determined by our task sequencer logic:\r\n *  - The controller informs the task sequencer about the request and the task player sending it. \r\n *  - The task sequencer tells the controller what to do next: Show a login dialog or start a task on a specific task player. \r\n *  - The controller stops the currently running task and \r\n *     * either shows a login dialog on the chosen task player \r\n *     * or starts the next task on the chosen task player.\r\n *  - If the task sequencer does not choose the next task player the controller picks one:\r\n *     * If the previous task player is compatible, it reuses that one. \r\n *     * Otherwise It picks some compatible player. \r\n * \r\n * Since the controller does not maintain any internal memory (for now) \r\n * it is just a method that configures the listeners in the message receiver.\r\n * \r\n */\r\n\r\n\r\n/**\r\n * Establish the controller, i.e. configure listeners in the message receiver. \r\n * \r\n * This defines our response to the messages coming in from the task players running in the CBA runtimes. \r\n * \r\n * The controller's activity is driven by the messages coming in from the task players: \r\n * - The 'ready' messages trigger the login phase.\r\n * - The 'login-done' message triggers the item initialization phase which will download items and start the first task of the assessment.\r\n * - Task switch request messages trigger task selection and task stop/start respones. \r\n */\r\nexport function configureMessageReceiver(\r\n  messageReceiver: MessageReceiver, \r\n  taskSequencer: TaskSequencer, \r\n  playerCatalog: PlayerCatalog,\r\n  itemCatalog: ItemCatalog,  \r\n  controllerConfig: ControllerConfiguration\r\n) \r\n{\r\n\r\n\r\n  // What to do once a task switch request arrives: get next action from task sequencer and run it.\r\n  messageReceiver.setTaskSwitchRequestListener((sendingWindow: MessageEventSource, request: RequestType, requestDetails?: TaskRequestDetails) => {\r\n    \r\n    const sendingPlayerId = playerCatalog.getPlayerId(sendingWindow);\r\n    if (sendingPlayerId === undefined) {\r\n      console.warn(`Received switch request from unknown task player frame. This is an internal error. We ignored the request.`);\r\n      return;\r\n    }\r\n    \r\n    const decision = getNextAction(sendingPlayerId, request, requestDetails, taskSequencer);\r\n    switch (decision.type) {\r\n      case 'blocked': \r\n        console.log(`Cannot follow switch request ${request}: ${decision.reason}. We ignored the request.`)\r\n        /********* \"Hack\" to send PM to parent frame when the last task of the sequence has been reached to signal the end of the test *******/\r\n        // if(request === \"nextTask\"){\r\n        //     window.parent.postMessage(\r\n        //       JSON.stringify({eventType: \"endOfSequence\"}),\r\n        //       \"*\"\r\n        //     );\r\n        // }\r\n        return;\r\n      case 'login': \r\n        processLoginRequest(decision.playerId, sendingPlayerId, sendingWindow, playerCatalog);\r\n        return;\r\n      case 'taskSwitch': \r\n        //task switch determined by shiny app based on scoring result\r\n          // processTaskSwitchRequest(decision.playerId, decision.nextTask, sendingPlayerId, sendingWindow, itemCatalog, playerCatalog);\r\n          getScoringResult(sendingWindow);\r\n        return;\r\n      default: \r\n        const _exhaustiveCheck : never = decision;\r\n        return _exhaustiveCheck;\r\n    }\r\n\r\n  })\r\n\r\n  messageReceiver.setShinyTaskSwitchRequestListener((sendingWindow: MessageEventSource, requestDetails: ShinySwitchRequest) => {\r\n    requestDetails.scope = requestDetails?.scope ? requestDetails.scope : \"Default\";\r\n    processShinyTaskSwitchRequest({item: requestDetails.item, task: requestDetails.task, scope: requestDetails.scope} as TaskIdentification, itemCatalog, playerCatalog);\r\n  });\r\n\r\n  messageReceiver.setShinyPreloadStateListener((sendingWindow: MessageEventSource, requestDetails: any) => {\r\n\r\n    const nextTask = !!requestDetails?.item ? requestDetails.item as TaskIdentification : taskSequencer.firstTask()?.firstTask;\r\n    if(!nextTask)\r\n      return;\r\n    \r\n    const targetItemVersion = itemCatalog.getVersion(nextTask.item);\r\n    if (targetItemVersion === undefined) {\r\n      console.warn(`Received task switch request to unknown item ${nextTask.item}. We ignored the request.`);\r\n      return;\r\n    }\r\n  \r\n    // const compatiblePlayer = getCompatiblePlayer(advisedPlayerId, targetItemVersion, {id: sendingPlayerId, frameWindow: sendingWindow}, playerCatalog);\r\n    const compatiblePlayer = playerCatalog.findCompatiblePlayer(targetItemVersion);\r\n    if (compatiblePlayer === undefined) {\r\n      console.warn(`Received task switch request to item ${nextTask.item} with version ${targetItemVersion} and could not find a compatible task player. We ignored the request.`);\r\n      return;\r\n    }\r\n\r\n    playerCatalog.doToAll((targetWindow: MessageEventSource) =>  stopTask(targetWindow));\r\n    // playerCatalog.doToAll((targetWindow: MessageEventSource) =>  sendMessageToTaskPlayer(targetWindow, {eventType: 'preloadTasksState', state: requestDetails?.state}));\r\n    // stopTask(compatiblePlayer.frameWindow);\r\n    sendMessageToTaskPlayer(compatiblePlayer.frameWindow, {eventType: 'preloadTasksState', state: requestDetails?.state});\r\n\r\n    playerCatalog.show(compatiblePlayer.id);\r\n    startTask(nextTask, compatiblePlayer.frameWindow);\r\n\r\n  });\r\n\r\n  // What to do once login is finished: Download configuration, set up everything, and start first task.\r\n  messageReceiver.setLoginDialogClosedListener((sendingWindow, nickname) => {\r\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setUserId(nickname, targetWindow));\r\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setTaskSequencer(targetWindow));\r\n    downloadAssessmentConfig()\r\n      .then((configuration) => {\r\n        if (configuration.tasks.length < 1) {\r\n          throw new Error(`No tasks declared in assessment configuration ${configuration}`);\r\n        }\r\n        taskSequencer.initialize(configuration, playerCatalog);\r\n        loadItemsAndStartFirstTask(configuration, controllerConfig.mathJaxCdnUrl, playerCatalog, itemCatalog, taskSequencer);\r\n      })\r\n      .catch((error) => {\r\n        console.warn(`Could not initialize assessment properly: ${error.message}`);\r\n      });\r\n  })\r\n  \r\n  // What to do once the task player is ready: Load required items and show login dialog.\r\n  messageReceiver.setPlayerReadyListener((sendingWindow) => {\r\n    playerCatalog.receiveReadySignal(sendingWindow);\r\n    \r\n    // initializeSessionAndShowLogin(sendingWindow, controllerConfig.traceLogTransmission, playerCatalog)\r\n    // setUserId(\"DEPP\", sendingWindow);\r\n\r\n    sendMessageToTaskPlayer(sendingWindow, {\r\n      eventType: 'setTraceLogTransmissionChannel', \r\n      channel: 'postMessage', \r\n      interval: 5000, \r\n      targetOrigin: '*', \r\n      targetWindowType: \"parent\"\r\n    });    \r\n    sendMessageToTaskPlayer(sendingWindow, {eventType: 'setTraceContextId', contextId: buildTraceContextId()});\r\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setUserId(extractUserIdFromQuery(\"session\"), targetWindow));\r\n    playerCatalog.doToAll((targetWindow: MessageEventSource) => setTaskSequencer(targetWindow));\r\n    downloadAssessmentConfig()\r\n    .then((configuration) => {\r\n        if (configuration.tasks.length < 1) {\r\n          throw new Error(`No tasks declared in assessment configuration ${configuration}`);\r\n        }\r\n        taskSequencer.initialize(configuration, playerCatalog);\r\n        playerCatalog.doToAll((targetWindow: MessageEventSource) => setScalingConfiguration(targetWindow, extractScalingConfigurationFromQuery()));      \r\n        loadItemsAndStartFirstTask(configuration, controllerConfig.mathJaxCdnUrl, playerCatalog, itemCatalog, taskSequencer);        \r\n      })       \r\n      .catch((error) => {\r\n        console.warn(`Could not initialize assessment properly: ${error.message}`);\r\n      });\r\n  });\r\n\r\n}\r\n\r\n/**\r\n * Obtain the next action by asking the task sequencer. \r\n */\r\n function getNextAction(\r\n  sendingPlayerId: string, \r\n  request: RequestType, \r\n  requestDetails: TaskRequestDetails | undefined, \r\n  taskSequencer: TaskSequencer\r\n  ) : Decision\r\n{\r\n  switch (request) {\r\n    case 'cancelTask': return taskSequencer.cancel(sendingPlayerId);\r\n    case 'nextTask': return taskSequencer.nextTask(sendingPlayerId);\r\n    case 'previousTask': return taskSequencer.backTask(sendingPlayerId);\r\n    case 'goToTask': {\r\n      if (requestDetails === undefined) return { type: 'blocked', reason: 'Task specification is missing in goToTask request.' }\r\n      return taskSequencer.goToTask(sendingPlayerId, requestDetails);\r\n    }\r\n    default: {\r\n      const _exhaustiveCheck: never = request;\r\n      return _exhaustiveCheck;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Process a request to show a new login.\r\n * \r\n * We stop the currently running task and show the login dialog.\r\n */\r\nfunction processLoginRequest(advisedPlayerId: string | undefined, sendingPlayerId: string, sendingWindow: MessageEventSource, playerCatalog: PlayerCatalog) : void {\r\n  const targetPlayer = getTargetPlayer(advisedPlayerId, sendingPlayerId, sendingWindow, playerCatalog);\r\n\r\n  stopTask(sendingWindow);\r\n  playerCatalog.doToAll((targetWindow: MessageEventSource) => {logout(targetWindow)});\r\n  playerCatalog.show(targetPlayer.id);\r\n  showLogin(targetPlayer.frameWindow);\r\n  return;\r\n}\r\n\r\n/**\r\n * Process a request to switch to another task.\r\n * \r\n * We stop the currently running task and start the new one.\r\n */\r\nfunction processTaskSwitchRequest(\r\n  advisedPlayerId: string | undefined, \r\n  nextTask: TaskIdentification, \r\n  sendingPlayerId: string, \r\n  sendingWindow: MessageEventSource, \r\n  itemCatalog: ItemCatalog, \r\n  playerCatalog: PlayerCatalog) : void \r\n{\r\n  const targetItemVersion = itemCatalog.getVersion(nextTask.item);\r\n  if (targetItemVersion === undefined) {\r\n    console.warn(`Received task switch request to unknown item ${nextTask.item}. We ignored the request.`);\r\n    return;\r\n  }\r\n\r\n  const compatiblePlayer = getCompatiblePlayer(advisedPlayerId, targetItemVersion, {id: sendingPlayerId, frameWindow: sendingWindow}, playerCatalog);\r\n  if (compatiblePlayer === undefined) {\r\n    console.warn(`Received task switch request to item ${nextTask.item} with version ${targetItemVersion} and could not find a compatible task player. We ignored the request.`);\r\n    return;\r\n  }\r\n  \r\n  getScoringResult(sendingWindow)\r\n  stopTask(sendingWindow);\r\n  playerCatalog.show(compatiblePlayer.id);\r\n  startTask(nextTask, compatiblePlayer.frameWindow);\r\n  return;\r\n\r\n}\r\n\r\nfunction processShinyTaskSwitchRequest(\r\n  nextTask: TaskIdentification,  \r\n  itemCatalog: ItemCatalog, \r\n  playerCatalog: PlayerCatalog) : void \r\n{\r\n  console.log(nextTask);\r\n  const targetItemVersion = itemCatalog.getVersion(nextTask.item);\r\n  if (targetItemVersion === undefined) {\r\n    console.warn(`Received task switch request to unknown item ${nextTask.item}. We ignored the request.`);\r\n    return;\r\n  }\r\n\r\n  // const compatiblePlayer = getCompatiblePlayer(advisedPlayerId, targetItemVersion, {id: sendingPlayerId, frameWindow: sendingWindow}, playerCatalog);\r\n  const compatiblePlayer = playerCatalog.findCompatiblePlayer(targetItemVersion);\r\n  if (compatiblePlayer === undefined) {\r\n    console.warn(`Received task switch request to item ${nextTask.item} with version ${targetItemVersion} and could not find a compatible task player. We ignored the request.`);\r\n    return;\r\n  }\r\n  \r\n  // stopTask(sendingWindow);\r\n  playerCatalog.doToAll(targetWindow => {\r\n    stopTask(targetWindow);\r\n  });\r\n  playerCatalog.show(compatiblePlayer.id);\r\n  startTask(nextTask, compatiblePlayer.frameWindow);\r\n  return;\r\n}\r\n \r\n/**\r\n * Load all required items and start the first task as advised by the task sequencer.\r\n */\r\nfunction loadItemsAndStartFirstTask(\r\n  configuration: AssessmentConfiguration, \r\n  mathJaxCdnUrl: string | undefined,\r\n  playerCatalog: PlayerCatalog, \r\n  itemCatalog: ItemCatalog,\r\n  taskSequencer: TaskSequencer,\r\n) : void {\r\n  Promise.resolve()\r\n    .then(() => installAllItems(configuration, mathJaxCdnUrl, playerCatalog, itemCatalog))\r\n    .then(() => {\r\n      const firstTask = taskSequencer.firstTask();\r\n      if (firstTask === undefined) {\r\n        throw new Error(`Invalid task sequencer configuration blocks starting the first task.`);\r\n      }\r\n      window.postMessage(JSON.stringify({eventType: \"itemsLoadedInPlayer\", playerCount: playerCatalog.getPlayerIds().length}),\"*\");\r\n      findCompatiblePlayerAndStartTask(firstTask, playerCatalog, itemCatalog)\r\n    })\r\n    .catch((error) => {\r\n      console.warn(`Could not properly initialize items and start first task: ${error.message}`);\r\n    });\r\n}\r\n\r\n/**\r\n * Build a promise that installs all items contained in the given assessment configuration.\r\n */\r\nfunction installAllItems(\r\n  assessmentConfiguration: AssessmentConfiguration, \r\n  mathJaxCdnUrl: string | undefined,\r\n  playerCatalog: PlayerCatalog,\r\n  itemCatalog: ItemCatalog\r\n  ) : Promise<void[]> \r\n{ \r\n  return Promise.all(\r\n      assessmentConfiguration.tasks\r\n        .map((taskConfiguration) => taskConfiguration.item)\r\n        .filter(onlyUnique)\r\n        .filter((itemName) => !itemCatalog.isRegistered(itemName))\r\n        .map((itemName) => installItem(itemName, mathJaxCdnUrl, playerCatalog, itemCatalog))\r\n  ); \r\n}\r\n\r\n/**\r\n * Is the given index the first occurrence of the given value in the given array?\r\n * \r\n * Using this method in a filter on an array will drop out all duplicates. \r\n */\r\n function onlyUnique<T>(value: T, index: number, all: T[]) : boolean {\r\n  return all.indexOf(value) === index;\r\n}\r\n\r\n/**\r\n * Build a promise that downloads the configuration for the item with the given name and installs it in the CBA runtime.\r\n */\r\nfunction installItem(\r\n  itemName: string, \r\n  mathJaxCdnUrl: string | undefined, \r\n  playerCatalog: PlayerCatalog, \r\n  itemCatalog: ItemCatalog) : Promise<void> {\r\n  const itemRootPathPrefix = `../items/${itemName}`;\r\n\r\n  return downloadItemConfig(itemName)\r\n    .then((itemConfiguration) => {\r\n      itemCatalog.register(itemConfiguration.name, itemConfiguration.runtimeCompatibilityVersion);\r\n      playerCatalog.doToAllCompatible(itemConfiguration.runtimeCompatibilityVersion, (targetWindow) => sendMessageToTaskPlayer(targetWindow, {\r\n        eventType: 'addItem', \r\n        itemConfig: itemConfiguration, \r\n        resourcePath: `${itemRootPathPrefix}/resources`,\r\n        externalResourcePath: `${itemRootPathPrefix}/external-resources`,\r\n        libraryPathsMap: { MathJax: mathJaxCdnUrl === undefined ? 'math-jax unknown' : mathJaxCdnUrl}\r\n      }));\r\n    })\r\n    .catch((error) => {\r\n      throw new Error(`Could not download configuration for item ${itemName}: ${error.message}`);\r\n    })\r\n}\r\n\r\n\r\n/**\r\n * Start the given task on a compatible player and make the player visible.\r\n */\r\nfunction findCompatiblePlayerAndStartTask(\r\n  startAdvice: { firstTask: TaskIdentification, playerId? : string},\r\n  playerCatalog: PlayerCatalog, \r\n  itemCatalog: ItemCatalog\r\n) : void \r\n{\r\n  const itemVersion = itemCatalog.getVersion(startAdvice.firstTask.item);\r\n  if (itemVersion === undefined) {\r\n    throw new Error(`Could not find item ${startAdvice.firstTask.item}.`);\r\n  }\r\n\r\n  const compatiblePlayer = getCompatiblePlayer(startAdvice.playerId, itemVersion, undefined, playerCatalog);\r\n  if (compatiblePlayer === undefined) {\r\n    throw new Error(`Could not find compatible player for item ${startAdvice.firstTask.item} with version ${itemVersion}.`);\r\n  }\r\n\r\n  playerCatalog.show(compatiblePlayer.id);\r\n  startTask(startAdvice.firstTask, compatiblePlayer.frameWindow);\r\n}\r\n\r\n/**\r\n * Do the initial steps once the task player is ready: \r\n *  - Assign a trace context id.\r\n *  - Configure the transmission channel for the trace log data.\r\n *  - Show a login box.\r\n */\r\n\r\n\r\n function initializeSessionAndShowLogin(\r\n   targetWindow: MessageEventSource, \r\n   logTransmissionConfig: LogTransmissionConfiguration | undefined, \r\n   playerCatalog: PlayerCatalog) {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setTraceContextId', contextId: buildTraceContextId()});\r\n  \r\n  // If no log transmission channel is configured we simply keep the default (i.e. log to console)\r\n  if (logTransmissionConfig !== undefined) {\r\n    sendMessageToTaskPlayer(targetWindow, {\r\n      eventType: 'setTraceLogTransmissionChannel', \r\n      channel: 'http', interval: logTransmissionConfig.interval, \r\n      httpTimeout: logTransmissionConfig.httpTimeout, \r\n      transmitUrl: logTransmissionConfig.transmitUrl })\r\n  }\r\n  else{\r\n    sendMessageToTaskPlayer(targetWindow, {\r\n      eventType: 'setTraceLogTransmissionChannel', \r\n      channel: 'postMessage', \r\n      interval: 5000,\r\n      targetOrigin: '*', \r\n      targetWindowType: \"parent\"});\r\n  }\r\n  \r\n  if (playerCatalog.allPlayersReady()) {\r\n    const targetPlayer = playerCatalog.getPlayerId(targetWindow);\r\n    if (targetPlayer === undefined) {\r\n      console.warn(`Received ready request from unknown task player frame. This is an internal error. The initial login dialog might be unstable.`);\r\n    } else {\r\n      playerCatalog.show(targetPlayer);\r\n    }\r\n    showLogin(targetWindow);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n* Establish ourselves as task sequencer in CBA runtime.\r\n */\r\nfunction setScalingConfiguration(targetWindow: MessageEventSource, sc :ScalingConfiguration) {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setScalingConfiguration', ...sc})\r\n}\r\n\r\n/**\r\n* Establish ourselves as task sequencer in CBA runtime.\r\n */\r\nfunction setTaskSequencer(targetWindow: MessageEventSource) {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setTaskSequencer', targetOrigin: window.location.origin, targetWindowType: 'parent'})\r\n}\r\n\r\n/**\r\n * Stop the running task in the CBA runtime.\r\n */\r\nfunction stopTask(targetWindow: MessageEventSource) : void {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'stopTask'});\r\n}\r\n\r\n/**\r\n * Start a task in the CBA runtime.\r\n */\r\nfunction startTask(toStart: TaskIdentification, targetWindow: MessageEventSource) : void {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'startTask', item: toStart.item, task: toStart.task, scope: toStart.scope});\r\n}\r\n\r\n/**\r\n * Request scoring result.\r\n */\r\nfunction getScoringResult(targetWindow: MessageEventSource) : void {\r\n  sendMessageToTaskPlayer(targetWindow, { eventType: 'getScoringResult'});\r\n}\r\n\r\n/**\r\n * Set the user ID in the CBA runtime.\r\n */\r\n function setUserId(userId: string, targetWindow: MessageEventSource) : void {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'setUserId', id: userId});\r\n}\r\n\r\n/**\r\n * Log out the current user.\r\n */\r\nfunction logout(targetWindow: MessageEventSource) : void {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: 'logout'});\r\n}\r\n\r\n/**\r\n * Trigger the login box in the CBA runtime.\r\n */\r\nfunction showLogin(targetWindow: MessageEventSource, ) {\r\n  sendMessageToTaskPlayer(targetWindow, {eventType: \"showLogin\", titleLabel: \"Placeholder for Login\", fieldLabel: \"Please enter anything (nickname) \", buttonLabel: \"Start\" });\r\n}\r\n\r\n/**\r\n * Build a unique trace context id. \r\n */\r\nfunction buildTraceContextId() : string {\r\n  return v4();\r\n}\r\n\r\n/**\r\n * Get the id of a compatible player.\r\n * \r\n * Return the advised player if that exists and is compatible. \r\n * Otherwise return the player of the sending window if that is given and is compatible. \r\n * Otherwise pick any compatible task player.\r\n * \r\n * We return undefined if no compatible task player is registered.\r\n */\r\nfunction getCompatiblePlayer(\r\n  advisedPlayerId: string | undefined, \r\n  itemVersion: string,\r\n  sendingPlayer: { id: string, frameWindow: MessageEventSource} | undefined, \r\n  playerCatalog: PlayerCatalog) \r\n  : { id: string, frameWindow: MessageEventSource } | undefined \r\n{\r\n  \r\n  if (advisedPlayerId !== undefined && playerCatalog.isCompatibleById(itemVersion, advisedPlayerId)) {\r\n    const frameWindow = playerCatalog.getFrameWindow(advisedPlayerId);\r\n    if (frameWindow === undefined) {\r\n      console.error(`Unexpected failure to find frame for registered player ${advisedPlayerId}. We try to find another compatible one.`);\r\n    } else {\r\n      return { id: advisedPlayerId, frameWindow: frameWindow };\r\n    }\r\n  }\r\n\r\n  if (sendingPlayer !== undefined && playerCatalog.isCompatibleById(itemVersion, sendingPlayer.id)) {\r\n    return sendingPlayer;\r\n  }\r\n\r\n  const someCompatiblePlayer = playerCatalog.findCompatiblePlayer(itemVersion);\r\n  return someCompatiblePlayer === undefined ? undefined : { id: someCompatiblePlayer.id, frameWindow: someCompatiblePlayer.frameWindow };\r\n}\r\n\r\n\r\n/**\r\n * Get the advised player if that is given and registered.\r\n * Otherwise return the given triggering player. \r\n */\r\nfunction getTargetPlayer(\r\n    advisedPlayerId: string | undefined, \r\n    sendingPlayerId: string, \r\n    sendingWindow: MessageEventSource, \r\n    playerCatalog: PlayerCatalog) \r\n    : { id: string, frameWindow:MessageEventSource } \r\n{\r\n  if (advisedPlayerId === undefined) {\r\n    return { id: sendingPlayerId, frameWindow: sendingWindow };\r\n  }\r\n\r\n  const advisedFrame = playerCatalog.getFrameWindow(advisedPlayerId);\r\n  if (advisedFrame === undefined) {\r\n    console.log(`Advised player for request is not regitered. We use the triggering player instead.`);\r\n    return { id: sendingPlayerId, frameWindow: sendingWindow }\r\n  }\r\n\r\n  return { id: advisedPlayerId, frameWindow: advisedFrame}\r\n}\r\n\r\n\r\n","import {AssessmentConfiguration} from \"../utils/FileDownload\"\r\nimport { TaskRequestDetails } from \"./MessageReceiver\";\r\nimport { TaskIdentification } from \"../utils/FileDownload\";\r\nimport PlayerCatalog from \"../runtime/PlayerCatalog\";\r\n\r\n/**\r\n * The component making all next/previous/cancel task decisions. \r\n * \r\n * We keep a memory of available tasks and the currently running task. \r\n * This implementation does not take the task player instances into account\r\n * and does not advise on the next task player to use.\r\n * \r\n * With no task player advice the controller\r\n * sticks to the task player which was used before\r\n * (if the player is able to run the requested item)\r\n * or picks some other compatible player. \r\n */\r\nexport default class TaskSequencer {\r\n  private currentTaskIndex : number | 'not set' = 'not set';\r\n  private tasks : TaskIdentification[] = [];\r\n\r\n  public initialize(assessmentConfiguration: AssessmentConfiguration, playerCatalog: PlayerCatalog) : void {\r\n    this.currentTaskIndex = 0;\r\n    this.tasks = assessmentConfiguration.tasks;\r\n  }\r\n\r\n  public firstTask() : { firstTask: TaskIdentification, playerId?: string } | undefined {\r\n    this.currentTaskIndex = 0;\r\n    return this.tasks.length < 1 ? undefined : { firstTask: this.tasks[0] };\r\n  }\r\n\r\n  public cancel(sendingPlayerId: string) : Decision {\r\n    return { type: 'login'};\r\n  }\r\n\r\n  public nextTask(sendingPlayerId: string) : Decision {\r\n    return this.switchAndReturnTask((currentIndex) => currentIndex + 1, 'no next task');\r\n  }\r\n\r\n  public backTask(sendingPlayerId: string) : Decision {\r\n    return this.switchAndReturnTask((currentIndex) => currentIndex - 1, 'no previous task');\r\n  }\r\n\r\n  public goToTask(sendingPlayerId: string, request: TaskRequestDetails) : Decision {\r\n    return this.switchAndReturnTask(\r\n      (_) => this.findMatchingTask(request),\r\n      `Task ${request.task} ${request.item === undefined ? 'with item unspecified' : ('in item ' + request.item)} and in scope ${request.scope} is not part of the assessment configuration.`);\r\n  }\r\n\r\n  /**\r\n   * Calculate the index to pick using the callback, check that it is in range, switch to that task and return it. \r\n   */\r\n  private switchAndReturnTask(getIndexToPick: (currentIndex : number) => number, failureMessage: string ) : Decision {\r\n    if (this.currentTaskIndex === 'not set') {\r\n      console.warn(`Task sequencer is not initialized properly. This blocks all task switches.`);\r\n      return { type: 'blocked', reason: 'Task sequencer not initialized properly.' };\r\n    }\r\n    const indexToPick = getIndexToPick(this.currentTaskIndex);\r\n    if (indexToPick < 0 || indexToPick > this.tasks.length - 1) return { type: 'blocked', reason: failureMessage };\r\n    this.currentTaskIndex = indexToPick;\r\n    return { type: 'taskSwitch', nextTask: this.tasks[this.currentTaskIndex]};\r\n  }\r\n\r\n  private findMatchingTask(request: TaskRequestDetails) : number {\r\n    if (!request.item) return this.tasks.findIndex((candidate) => request.task === candidate.task && request.scope === candidate.scope)\r\n    return this.tasks.findIndex((candidate) => request.item === candidate.item && request.task === candidate.task && request.scope === candidate.scope)\r\n  }\r\n  \r\n}\r\n\r\n\r\n/**\r\n * The decision returned at the requests like cancel, nextTask etc.\r\n */\r\nexport type Decision = \r\n  { \r\n    type: 'login',\r\n    playerId?: string\r\n  } | \r\n  {\r\n    type: 'taskSwitch',\r\n    nextTask: TaskIdentification,\r\n    playerId?: string\r\n  } | \r\n  {\r\n    type: 'blocked'\r\n    reason: string\r\n  }\r\n\r\n\r\n","/**\r\n * The component managing all available task players (i.e. the available CBA runtimes in the player frames).\r\n * \r\n * The application established multiple CBA runtimes (with different runtime versions).\r\n * Each CBA runtime lives in its own IFrame and runs a task player.\r\n * \r\n * This catalog keeps track of all available task players. \r\n * \r\n * Each task player instance: \r\n *  - Is identified by a unique id string.\r\n *  - Runs in a frame with a frame window that should be used to send messages to the task player instance.\r\n */\r\nexport default class PlayerCatalog {\r\n  private readonly totalPlayerCount : number;\r\n  private readonly players : PlayerInfo[] = [];\r\n  private readonly pendingReadySignals : Set<MessageEventSource> = new Set<MessageEventSource>();  \r\n\r\n\r\n  // ------------ public interface -----------------------------------------------\r\n\r\n  /**\r\n   * Build the player catalog. \r\n   * \r\n   * We need the final total count of task players a priori:\r\n   * The controller should wait with the first login until all task players are ready \r\n   * to receive messages. We determine whether all task players are registered already\r\n   * by comparing with this total number of expected task players. \r\n   * \r\n   * @param totalPlayerCount The total number of task players that will register. \r\n   */\r\n  constructor(totalPlayerCount: number) {\r\n    this.totalPlayerCount = totalPlayerCount;\r\n  }\r\n\r\n  /**\r\n   * Register a new task player instance in our catalog.\r\n   * \r\n   * We implicitly set the is-ready flag for the task player\r\n   * if we already received its ready message earlier.\r\n   */\r\n  public registerPlayer(\r\n    id: string, \r\n    frameWindow: MessageEventSource, \r\n    frameRef: React.MutableRefObject<HTMLIFrameElement|null>, \r\n    compatibilityChecker: (itemVersion: string) => boolean\r\n    ) : void \r\n  {\r\n    const newPlayer = {id, frameWindow, frameRef, isCompatible: compatibilityChecker, readyFlag: false};\r\n    this.players.push(newPlayer);\r\n    this.applyPendingReadySignal(newPlayer);\r\n    if (this.totalPlayerCount < this.players.length) {\r\n      console.warn(`Unexpected registration of another task player ${id} as number ${this.players.length}. Check the total player count: ${this.totalPlayerCount}. We might have started the first login prematurely!`)\r\n    }\r\n\r\n    console.info(`Registered player ${id}`);\r\n  }\r\n\r\n\r\n  /**\r\n   * Process an incoming is-ready message from a task player instance.\r\n   * \r\n   * If the task player instance is already registered we set its ready flag. \r\n   * Otherwise we memorize the message and apply it once the task player instance is registered.\r\n   */\r\n  public receiveReadySignal(sourceWindow: MessageEventSource) : void {\r\n    const receivingPlayer = this.findPlayerByWindow(sourceWindow);\r\n    if (receivingPlayer === undefined) {\r\n      this.pendingReadySignals.add(sourceWindow);\r\n    } else {\r\n      receivingPlayer.readyFlag = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Are all task players ready to receive messages?\r\n   */\r\n   public allPlayersReady() : boolean {\r\n    return this.players.length >= this.totalPlayerCount && this.players.every(candidate => candidate.readyFlag);\r\n  }\r\n\r\n  /**\r\n   * Get the window of the frame where the task player with the given id is running.\r\n   * \r\n   * This window may be used to send messages to the task player instance.\r\n   *    \r\n   * We return undefined if no task player instance is registered for the given id.\r\n   */\r\n  public getFrameWindow(playerId: string) : MessageEventSource | undefined {\r\n    return this.findPlayerById(playerId)?.frameWindow;\r\n  }\r\n\r\n\r\n  /**\r\n   * Get the id of the task player instance running in the given frame window.\r\n   * \r\n   * We return undefined if no task player instance is registered for the given frame window.\r\n   */\r\n   public getPlayerId(sourceWindow: MessageEventSource) : string | undefined {\r\n    return this.findPlayerByWindow(sourceWindow)?.id;\r\n  }\r\n\r\n  /**\r\n   * Find a player that is compatible with the given item version. \r\n   * \r\n   * We return undefined if no such player is registered. \r\n   * If there is more than one compatbile player we return the first one\r\n   * in registration order.\r\n   */\r\n  public findCompatiblePlayer(itemVersion: string) : { id: string, frameWindow: MessageEventSource } | undefined {\r\n    return this.players.find(candidate => candidate.isCompatible(itemVersion));\r\n  }\r\n\r\n  /**\r\n   * Determine whether the given item version is compatible with the given task player instance.\r\n   * \r\n   * We return false if no task player for the given id is registered.\r\n   */\r\n  public isCompatibleById(itemVersion: string, playerId: string) : boolean | undefined {\r\n    const playerInfo = this.findPlayerById(playerId);\r\n    return playerInfo !== undefined && playerInfo.isCompatible(itemVersion);\r\n  } \r\n\r\n  /**\r\n   * Determine whether the given item version is compatible with the given task player instance.\r\n   * \r\n   * We return false if no task player for the given window is registered.\r\n   */\r\n  public isCompatibleByWindow(itemVersion: string, targetWindow: MessageEventSource) : boolean | undefined {\r\n    const playerInfo = this.findPlayerByWindow(targetWindow);\r\n      return playerInfo !== undefined && playerInfo.isCompatible(itemVersion);\r\n  } \r\n  \r\n  /**\r\n   * Run the given action on all registered task players.\r\n   */\r\n  public doToAll(action: (targetWindow: MessageEventSource) => void) {\r\n    this.players.forEach(player => action(player.frameWindow));\r\n  }\r\n\r\n  /**\r\n   * Run the given action on all registered and compatible task players.\r\n   */\r\n   public doToAllCompatible(itemVersion: string, action: (targetWindow: MessageEventSource) => void) {\r\n    this.players.filter(player => player.isCompatible(itemVersion)).forEach(player => action(player.frameWindow));\r\n  }\r\n\r\n\r\n  /**\r\n   * Make the given player visible to the user (i.e. make its Iframe visible).\r\n   */\r\n  public show(playerId: string) : void {\r\n    this.players.forEach(player => {\r\n      const frame : HTMLIFrameElement | null = player.frameRef.current;\r\n      if (frame === null) {\r\n        console.warn(`Cannot switch visibility for player ${player.id} since frame element is null.`);\r\n        return;\r\n      }\r\n      frame.style.visibility = player.id === playerId ? 'visible' : 'collapse';\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get the ids of all registered task players.\r\n   */\r\n  public getPlayerIds() : string[] {\r\n    return this.players.map(player => player.id);\r\n  }\r\n\r\n  // ------------ private methods ----------------------------------------------\r\n\r\n  /**\r\n   * Apply a pending is-ready message for the given player instance and \r\n   * drop it from the pending list. \r\n   * \r\n   * We do nothing if no is-ready message is on the pending list\r\n   * for the given task player instance.\r\n   */\r\n  private applyPendingReadySignal(player: PlayerInfo) : void {\r\n    const playerWindow : MessageEventSource = player.frameWindow;\r\n    if (this.pendingReadySignals.has(playerWindow)) {\r\n      player.readyFlag = true;\r\n      this.pendingReadySignals.delete(playerWindow);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the task player instance info for the given task player frame window.\r\n   */\r\n  private findPlayerByWindow(frameWindow: MessageEventSource) : PlayerInfo | undefined {\r\n    return this.players.find(candidate => candidate.frameWindow === frameWindow)\r\n  }\r\n\r\n  /**\r\n   * Find the task player instance info for the given task player id.\r\n   */\r\n   private findPlayerById(playerId: String) : PlayerInfo | undefined {\r\n    return this.players.find(candidate => candidate.id === playerId)\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Information about a task player in the task player catalog.\r\n */\r\n interface PlayerInfo {\r\n  id: string,\r\n  frameWindow: MessageEventSource,\r\n  frameRef: React.MutableRefObject<HTMLIFrameElement|null>\r\n  readyFlag: boolean,\r\n  isCompatible: (itemVersion: string) => boolean,\r\n}\r\n","/**\r\n * The component managing all items that were downloaded already. \r\n * \r\n * Each item is identified by its unique name string.\r\n * We keep the version number for each item.\r\n */\r\nexport default class ItemCatalog {\r\n  private items : ItemInfo[] = [];\r\n\r\n  /**\r\n   * Register an item in the catalog.\r\n   */\r\n  public register(name: string, version: string) : void {\r\n    this.items.push({name: name, version: version});\r\n  }\r\n\r\n  /**\r\n   * Is an item with the given name already registered in the catalog?\r\n   */\r\n  public isRegistered(name: string) : boolean {\r\n    return this.findByName(name) !== undefined;\r\n  }\r\n\r\n  /**\r\n   * Get the runtime version of an item.\r\n   * \r\n   * We return undefined if no item with the given name was already registered.\r\n   */\r\n  public getVersion(name: string) : string | undefined {\r\n    return this.findByName(name)?.version;\r\n  }\r\n\r\n  /**\r\n   * Private helper: Find an item in the catalog.\r\n   */\r\n  private findByName(name: string) : ItemInfo | undefined {\r\n    return this.items.find(candidate => candidate.name === name);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Internal item representation in the catalog.\r\n */\r\ninterface ItemInfo {\r\n  name: string, \r\n  version: string\r\n}\r\n\r\n\r\n","import React, { useEffect } from 'react';\r\nimport { PlayerConfiguration } from '../utils/FileDownload';\r\nimport PlayerCatalog from './PlayerCatalog';\r\n\r\n/**\r\n * An IFrame containing a CBA runtime running a task player.\r\n * \r\n * The component registers the task player as soon as the IFrame \r\n * is available. \r\n * \r\n * The properties itemWidth and itemHeight specify the size of the IFrame.\r\n * We load the source file for the IFrame from the react-runtime subfolder.\r\n */\r\nexport default function PlayerFrame( props: {\r\n    itemWidth: number, \r\n    itemHeight: number,\r\n    showPlayerInfo: boolean,\r\n    playerConfiguration: PlayerConfiguration,\r\n    playerCatalog: PlayerCatalog\r\n  }) : JSX.Element\r\n{\r\n\r\n  const { playerId, runtimeVersion, frameContentFile } = props.playerConfiguration;\r\n\r\n  // The late-binding references to the CBA-runtime IFrame element and the containing div element:\r\n  const frameRef: React.MutableRefObject<HTMLIFrameElement|null> = React.useRef(null);\r\n  const divRef: React.MutableRefObject<HTMLIFrameElement|null> = React.useRef(null);\r\n \r\n\r\n  // Once our frame is mounted register the player in the player catalog:\r\n  useEffect(() => {\r\n    const contentWindow = frameRef.current?.contentWindow;\r\n    if (contentWindow === null || contentWindow === undefined) {\r\n      console.warn(`Content window of task player frame is invalid!`);\r\n      return;\r\n    }\r\n    props.playerCatalog.registerPlayer(playerId, contentWindow, divRef, (itemVersion) => itemVersion === runtimeVersion);\r\n  }, [props.playerCatalog, playerId, runtimeVersion]);\r\n\r\n  return (\r\n    <div className='PlayerFrame' \r\n      ref={divRef}\r\n      style={{position: 'absolute', top: '0px', left: '0px', borderStyle: 'none', width: '100%', height: '100%', display: 'flex', alignItems: 'baseline', justifyContent: 'center'}}\r\n    >\r\n      { !props.showPlayerInfo || \r\n        <div style={{fontSize: 'xx-small' }}>\r\n          Current Player: {playerId }, Version: {runtimeVersion}\r\n        </div>\r\n      }\r\n      <iframe\r\n        ref={frameRef}\r\n        style={\r\n          { \r\n            width: '100%',\r\n            height: '100%'\r\n            // width: props.itemWidth + 'px',\r\n            // height: props.itemHeight + 'px'\r\n          }\r\n        }\r\n        title='PlayerFrame'\r\n        src={`./react-runtime/${frameContentFile}?eventTargetWindow=parent`}       \r\n        frameBorder=\"0\"  \r\n        scrolling=\"no\"  \r\n        className='cbaframe'\r\n      />\r\n    </div>\r\n  )\r\n}\r\n\r\n","import React from 'react';\r\nimport './App.css';\r\nimport MessageReceiver from './MessageReceiver';\r\nimport { configureMessageReceiver } from './Controller';\r\nimport TaskSequencer from './TaskSequencer';\r\nimport PlayerCatalog from '../runtime/PlayerCatalog';\r\nimport ItemCatalog from '../runtime/ItemCatalog';\r\nimport { ControllerConfiguration } from '../utils/FileDownload';\r\nimport PlayerFrame from '../runtime/PlayerFrame';\r\n\r\n/**\r\n * The layer that sets up all components: \r\n *  - The catalogs of items and task players.\r\n *  - The task sequencer.\r\n *  - The listeners in the message receiver.\r\n *  - The IFrames that contain the CBA runtimes with different runtime versions.\r\n * \r\n * The 'controller' is not a component (for now). \r\n * It is implemented as a set of listeners registered\r\n * in the message receiver.\r\n */\r\nexport function App(props: { messageReceiver : MessageReceiver, controllerConfiguration: ControllerConfiguration}) : JSX.Element {\r\n\r\n  const { messageReceiver, controllerConfiguration } = props;\r\n\r\n  // All task players that we support.\r\n  const playersArray = controllerConfiguration.players;\r\n\r\n  // The catalog of all the task players running in their Iframes:\r\n  const playerCatalog : PlayerCatalog = new PlayerCatalog(playersArray.length);\r\n\r\n  // The catalog of all items that are currently loaded to all compatible the task players:\r\n  const itemCatalog : ItemCatalog = new ItemCatalog();\r\n\r\n  // The task sequencer that decides which task to run next:\r\n  const taskSequencer : TaskSequencer = new TaskSequencer();\r\n\r\n  // Establish our behavior, i.e. our reactions to events coming in from the task players:\r\n  configureMessageReceiver(\r\n    messageReceiver, \r\n    taskSequencer, \r\n    playerCatalog, \r\n    itemCatalog, \r\n    controllerConfiguration);\r\n  \r\n  const itemHeight = controllerConfiguration.itemSize === undefined ? 768 : controllerConfiguration.itemSize.height;\r\n  const itemWidth = controllerConfiguration.itemSize === undefined ? 1024 : controllerConfiguration.itemSize.width;\r\n\r\n  return (\r\n    <div className='App' >\r\n      { playersArray.map(player => \r\n        <PlayerFrame\r\n          key={player.playerId}\r\n          itemWidth={itemWidth} \r\n          itemHeight={itemHeight}\r\n          showPlayerInfo = {controllerConfiguration.showPlayerInfo}\r\n          playerConfiguration = {player}\r\n          playerCatalog={playerCatalog}\r\n        />\r\n        )\r\n      }      \r\n    </div>\r\n  );\r\n}\r\n\r\n\r\n\r\n/**\r\n * Create and initialize the message receiver.\r\n * \r\n * We start its receiving loop on the global window.\r\n * \r\n * We create the message receiver outside of ReactDOM.render \r\n * to make sure it is not created multiple times\r\n * which would lead to multiple listeners on the global window.\r\n * \r\n */\r\nexport function buildMessageReceiver() : MessageReceiver {\r\n  const result = new MessageReceiver();\r\n  result.startReceiving();\r\n  return result;\r\n}\r\n\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {App, buildMessageReceiver} from './controller/App';\r\nimport { ControllerConfiguration, downloadControllerConfig } from './utils/FileDownload';\r\n\r\n/**\r\n * The entry point into the application.\r\n */\r\n\r\n// We start the application rendering after fetching our controller configuration.\r\ndownloadControllerConfig()\r\n.then((controllerConfiguration: ControllerConfiguration) => {\r\n  // We create the message receiver here to make sure it is created exactly once:\r\n  const messageReceiver = buildMessageReceiver();\r\n  \r\n  ReactDOM.render(\r\n    <React.StrictMode>\r\n      <App messageReceiver={messageReceiver} controllerConfiguration={controllerConfiguration} />\r\n    </React.StrictMode>,\r\n    document.getElementById('ee4basicsRoot')\r\n  );  \r\n})\r\n.catch((error) => {\r\n  console.warn(`Could not initialize assessment properly: ${error.message}`);\r\n});\r\n"],"sourceRoot":""}